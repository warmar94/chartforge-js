class ChartForge{constructor(options={}){this.version='1.0.0';this.charts=new Map();this.darkMode=options.darkMode!==undefined?options.darkMode:!1;this.designs={default:{background:{light:'transparent',dark:'transparent'},colors:['#8B5CF6','#3B82F6','#10B981','#F59E0B','#EF4444','#EC4899','#06B6D4','#84CC16','#F97316','#6366F1'],textColor:{light:'#111827',dark:'#F3F4F6'},gridColor:{light:'#E5E7EB',dark:'#374151'},borderColor:{light:'#D1D5DB',dark:'#4B5563'},borderRadius:8,shadowBlur:10,shadowOffset:2,fontFamily:'Inter, system-ui, sans-serif',fontSize:12,fontWeight:'normal',animations:!1,animationDuration:0,glowEffect:!1},minimalistic:{background:{light:'linear-gradient(135deg, rgba(243, 244, 246, 0.8), rgba(229, 231, 235, 0.6))',dark:'linear-gradient(135deg, rgba(17, 24, 39, 0.8), rgba(31, 41, 55, 0.6))'},colors:['#6B7280','#9CA3AF','#D1D5DB','#F3F4F6','#E5E7EB'],textColor:{light:'#374151',dark:'#D1D5DB'},gridColor:{light:'#F3F4F6',dark:'#374151'},borderColor:{light:'#E5E7EB',dark:'#4B5563'},borderRadius:0,shadowBlur:0,shadowOffset:0,fontFamily:'ui-monospace, monospace',fontSize:11,fontWeight:'normal',animations:!1,animationDuration:0,glowEffect:!1},modern:{background:{light:'linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.12))',dark:'linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.25))'},colors:['#6366F1','#8B5CF6','#EC4899','#EF4444','#F59E0B','#10B981','#06B6D4','#84CC16'],textColor:{light:'#1F2937',dark:'#F9FAFB'},gridColor:{light:'#E5E7EB',dark:'#374151'},borderColor:{light:'#C7D2FE',dark:'#6366F1'},borderRadius:12,shadowBlur:15,shadowOffset:3,fontFamily:'Inter, system-ui, sans-serif',fontSize:12,fontWeight:'500',animations:!1,animationDuration:0,glowEffect:!0},cyberpunk:{background:{light:'linear-gradient(135deg, rgba(0, 255, 255, 0.05), rgba(255, 0, 255, 0.08))',dark:'linear-gradient(135deg, rgba(0, 255, 255, 0.15), rgba(255, 0, 255, 0.2))'},colors:['#00FFFF','#FF00FF','#00FF00','#FFFF00','#FF0080','#8000FF','#FF4000','#00FF80'],textColor:{light:'#025a5a',dark:'#00FFFF'},gridColor:{light:'rgba(0, 255, 255, 0.3)',dark:'rgba(0, 255, 255, 0.2)'},borderColor:{light:'#00FFFF',dark:'#FF00FF'},borderRadius:0,shadowBlur:20,shadowOffset:0,fontFamily:'ui-monospace, monospace',fontSize:11,fontWeight:'bold',animations:!1,animationDuration:0,glowEffect:!0},professional:{background:{light:'linear-gradient(135deg, rgba(248, 250, 252, 0.9), rgba(241, 245, 249, 0.8))',dark:'linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.8))'},colors:['#1E40AF','#059669','#DC2626','#D97706','#7C3AED','#BE185D','#0891B2','#65A30D'],textColor:{light:'#1F2937',dark:'#F9FAFB'},gridColor:{light:'#E5E7EB',dark:'#374151'},borderColor:{light:'#D1D5DB',dark:'#4B5563'},borderRadius:6,shadowBlur:8,shadowOffset:1,fontFamily:'ui-sans-serif, system-ui, sans-serif',fontSize:11,fontWeight:'normal',animations:!1,animationDuration:0,glowEffect:!1},custom:{background:{light:'transparent',dark:'transparent'},colors:['#8B5CF6','#3B82F6','#10B981','#F59E0B','#EF4444','#EC4899','#06B6D4','#84CC16','#F97316','#6366F1'],textColor:{light:'#111827',dark:'#F3F4F6'},gridColor:{light:'#E5E7EB',dark:'#374151'},borderColor:{light:'#D1D5DB',dark:'#4B5563'},borderRadius:8,shadowBlur:10,shadowOffset:2,fontFamily:'Inter, system-ui, sans-serif',fontSize:12,fontWeight:'normal',animations:!1,animationDuration:0,glowEffect:!1}};this.currentDesign={...this.designs[options.design||'default']};if(options.customColor&&Array.isArray(options.colors)){this.currentDesign.colors=[...options.colors]}
if(options.animations!==undefined){this.currentDesign.animations=options.animations}
if(options.animationDuration!==undefined){this.currentDesign.animationDuration=options.animationDuration}
if(options.glowEffect!==undefined){this.currentDesign.glowEffect=options.glowEffect}}
isDarkMode(){return this.darkMode}
setDarkMode(darkMode){this.darkMode=darkMode;this.charts.forEach(chart=>{if(chart.redraw)chart.redraw();})}
getDesignValue(key,fallback=null){const design=this.currentDesign||this.designs.default;const isDark=this.isDarkMode();if(typeof design[key]==='object'&&design[key].light&&design[key].dark){return design[key][isDark?'dark':'light']}
return design[key]||fallback}
formatNumber(num,useKFormat=!1,prefix='',afterfix=''){if(typeof num!=='number'||isNaN(num))return `${prefix}N/A${afterfix}`;if(!useKFormat)return `${prefix}${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}${afterfix}`;if(num>=1e12)return `${prefix}${(num / 1e12).toFixed(1)}T${afterfix}`;if(num>=1e9)return `${prefix}${(num / 1e9).toFixed(1)}B${afterfix}`;if(num>=1e6)return `${prefix}${(num / 1e6).toFixed(1)}M${afterfix}`;if(num>=1e3)return `${prefix}${(num / 1e3).toFixed(1)}K${afterfix}`;return `${prefix}${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}${afterfix}`}
formatLabel(label,prefix='',afterfix=''){if(label===null||label===undefined)return `${prefix}N/A${afterfix}`;return `${prefix}${label}${afterfix}`}
validateNumber(value){return typeof value==='number'&&!isNaN(value)?value:0}
easeInOutCubic(t){return t<0.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}
createChart(containerId,type,options={}){const container=document.getElementById(containerId);if(!container){throw new Error(`Container with ID '${containerId}' not found`)}
this.currentDesign={...this.designs[options.design||'default']};if(options.customColor&&Array.isArray(options.colors)){this.currentDesign.colors=[...options.colors]}
if(options.animations!==undefined){this.currentDesign.animations=options.animations}
if(options.animationDuration!==undefined){this.currentDesign.animationDuration=options.animationDuration}
if(options.glowEffect!==undefined){this.currentDesign.glowEffect=options.glowEffect}
let chart;switch(type.toLowerCase()){case 'pie':chart=new ChartForgePie(containerId,options,this);break;case 'column':chart=new ChartForgeColumn(containerId,options,this);break;case 'bar':chart=new ChartForgeBar(containerId,options,this);break;case 'line':chart=new ChartForgeLine(containerId,options,this);break;case 'area':chart=new ChartForgeArea(containerId,options,this);break;case 'candlestick':chart=new ChartForgeCandlestick(containerId,options,this);break;case 'bubble':chart=new ChartForgeBubble(containerId,options,this);break;case 'treemap':chart=new ChartForgeTreeMap(containerId,options,this);break;case 'radialbar':chart=new ChartForgeRadialBar(containerId,options,this);break;default:throw new Error(`Chart type '${type}' is not supported`)}
this.charts.set(containerId,chart);return chart}
toggleTheme(){this.setDarkMode(!this.darkMode)}}
class ChartForgePie{constructor(containerId,options={},forge){this.container=document.getElementById(containerId);if(!this.container)throw new Error(`Container with ID '${containerId}' not found`);this.forge=forge;this.canvas=null;this.ctx=null;this.data=[];this.options={innerRadius:0,showLabels:!0,showLegend:!0,showTooltip:!0,showValues:!0,startAngle:-Math.PI/2,fillOpacity:0.3,useKFormat:!1,valuePrefix:'',valueAfterfix:'',...options};this.tooltip=null;this.animationFrame=null;this.currentAngles=[];this.targetAngles=[];this.animationProgress=0;this.hoveredSlice=-1;this.chartContainer=null;this.legendContainer=null;this.init();this.setupEventListeners()}
init(){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';this.container.innerHTML=`
            <div class="chartforge-pie-container" style="width: 100%; height: 100%; position: relative; background: ${this.forge.getDesignValue('background')};">
                <canvas style="width: 100%; height: 100%;"></canvas>
                <div class="chartforge-tooltip" style="position: absolute; display: none; background: rgba(17, 24, 39, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);"></div>
                <div class="chartforge-legend" style="position: absolute; top: 20px; right: 20px; background: ${legendBackground}; padding: 16px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); max-width: 200px; z-index: 1000; display: ${this.options.showLegend ? 'block' : 'none'};">
                    <div class="legend-items"></div>
                </div>
            </div>
        `;this.chartContainer=this.container.querySelector('.chartforge-pie-container');this.canvas=this.container.querySelector('canvas');this.ctx=this.canvas.getContext('2d');this.tooltip=this.container.querySelector('.chartforge-tooltip');this.legendContainer=this.container.querySelector('.legend-items');this.setupCanvas()}
updateContainerBackground(){if(this.chartContainer){this.chartContainer.style.background=this.forge.getDesignValue('background')}
const legendElement=this.container.querySelector('.chartforge-legend');if(legendElement){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';legendElement.style.background=legendBackground}}
setupCanvas(){const resizeCanvas=()=>{const rect=this.canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;this.canvas.width=rect.width*dpr;this.canvas.height=rect.height*dpr;this.ctx.scale(dpr,dpr);this.canvas.style.width=rect.width+'px';this.canvas.style.height=rect.height+'px';this.draw()};resizeCanvas();window.addEventListener('resize',resizeCanvas)}
setupEventListeners(){this.canvas.addEventListener('mousemove',(e)=>this.handleMouseMove(e));this.canvas.addEventListener('mouseleave',()=>this.hideTooltip());const observer=new MutationObserver(()=>{this.redraw()});observer.observe(document.documentElement,{attributes:!0,attributeFilter:['class']})}
setData(data){this.data=data.map((item,index)=>({...item,color:item.color||this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length],valuePrefix:item.valuePrefix||this.options.valuePrefix,valueAfterfix:item.valueAfterfix||this.options.valueAfterfix}));const total=this.data.reduce((sum,item)=>sum+(item.value||0),0);this.data.forEach(item=>{item.percentage=total>0?(item.value/total)*100:0});this.calculateAngles();if(this.forge.currentDesign.animations){this.animate()}else{this.currentAngles=[...this.targetAngles];this.draw()}
this.updateLegend()}
calculateAngles(){this.targetAngles=[];let currentAngle=this.options.startAngle;this.data.forEach(item=>{const angle=(item.percentage/100)*2*Math.PI;this.targetAngles.push({start:currentAngle,end:currentAngle+angle,item:item});currentAngle+=angle});if(this.currentAngles.length===0){this.currentAngles=this.targetAngles.map(angle=>({start:this.options.startAngle,end:this.options.startAngle,item:angle.item}))}}
animate(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
this.animationProgress=0;const startTime=Date.now();const animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/this.forge.currentDesign.animationDuration,1);if(this.animationProgress>=1){this.currentAngles=[...this.targetAngles]}else{const easeProgress=this.forge.easeInOutCubic(this.animationProgress);while(this.currentAngles.length<this.targetAngles.length){this.currentAngles.push({start:this.options.startAngle,end:this.options.startAngle,item:this.targetAngles[this.currentAngles.length].item})}
this.currentAngles=this.targetAngles.map((target,index)=>{const current=this.currentAngles[index];return{start:current.start+(target.start-current.start)*easeProgress,end:current.end+(target.end-current.end)*easeProgress,item:target.item}})}
this.draw();if(this.animationProgress<1){this.animationFrame=requestAnimationFrame(animate)}};animate()}
draw(){const rect=this.canvas.getBoundingClientRect();const centerX=rect.width/2;const centerY=rect.height/2;const outerRadius=Math.min(centerX,centerY)*0.8;const innerRadius=outerRadius*(this.options.innerRadius||0);this.ctx.clearRect(0,0,rect.width,rect.height);if(this.data.length===0){this.drawEmptyState(centerX,centerY,outerRadius);return}
this.currentAngles.forEach((angle,index)=>{const isHovered=this.hoveredSlice===index;const radius=isHovered?outerRadius+8:outerRadius;this.drawSlice(centerX,centerY,radius,innerRadius,angle.start,angle.end,angle.item.color,index);if(this.options.showLabels||this.options.showValues){this.drawLabel(centerX,centerY,outerRadius,angle.start,angle.end,angle.item)}});if(this.options.innerRadius>0){this.ctx.beginPath();this.ctx.arc(centerX,centerY,innerRadius,0,2*Math.PI);this.ctx.fillStyle=this.forge.getDesignValue('background','white');this.ctx.fill()}}
drawSlice(centerX,centerY,outerRadius,innerRadius,startAngle,endAngle,color,index){this.ctx.beginPath();if(innerRadius>0){this.ctx.arc(centerX,centerY,outerRadius,startAngle,endAngle);this.ctx.arc(centerX,centerY,innerRadius,endAngle,startAngle,!0)}else{this.ctx.moveTo(centerX,centerY);this.ctx.arc(centerX,centerY,outerRadius,startAngle,endAngle)}
this.ctx.closePath();if(this.forge.currentDesign.glowEffect){this.ctx.shadowColor=color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;this.ctx.shadowOffsetX=this.forge.currentDesign.shadowOffset;this.ctx.shadowOffsetY=this.forge.currentDesign.shadowOffset}
this.ctx.fillStyle=color;this.ctx.fill();this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0;this.ctx.shadowOffsetX=0;this.ctx.shadowOffsetY=0;this.ctx.strokeStyle=this.forge.getDesignValue('borderColor');this.ctx.lineWidth=1;this.ctx.stroke();if(this.hoveredSlice===index){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.stroke()}}
drawLabel(centerX,centerY,radius,startAngle,endAngle,item){const midAngle=(startAngle+endAngle)/2;const sliceAngle=Math.abs(endAngle-startAngle);const isSmallSlice=sliceAngle<0.1;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.textAlign='center';this.ctx.textBaseline='middle';const fontSize=isSmallSlice?this.forge.currentDesign.fontSize*0.8:this.forge.currentDesign.fontSize;this.ctx.font=`${this.forge.currentDesign.fontWeight} ${fontSize}px ${this.forge.currentDesign.fontFamily}`;const label=item.name||`Item ${this.data.indexOf(item) + 1}`;const formattedValue=this.forge.formatNumber(item.value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);let labelRadius=radius*0.7;const labelWidth=this.ctx.measureText(label).width;const valueWidth=this.ctx.measureText(formattedValue).width;const maxWidth=Math.max(labelWidth,valueWidth);if(maxWidth>radius*0.3){labelRadius=radius*0.85}
const x=centerX+Math.cos(midAngle)*labelRadius;const y=centerY+Math.sin(midAngle)*labelRadius;if(this.options.showLabels&&this.options.showValues&&!isSmallSlice){this.ctx.fillText(label,x,y-fontSize*0.6);this.ctx.fillText(`${formattedValue} (${item.percentage.toFixed(1)}%)`,x,y+fontSize*0.6)}else if(this.options.showLabels){this.ctx.fillText(label,x,y)}else if(this.options.showValues){this.ctx.fillText(`${formattedValue} (${item.percentage.toFixed(1)}%)`,x,y)}}
drawEmptyState(centerX,centerY,radius){this.ctx.fillStyle=this.forge.getDesignValue('gridColor');this.ctx.beginPath();this.ctx.arc(centerX,centerY,radius,0,2*Math.PI);this.ctx.fill();this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize + 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('No Data',centerX,centerY)}
updateLegend(){if(!this.legendContainer)return;this.legendContainer.parentElement.style.display=this.options.showLegend?'block':'none';this.legendContainer.innerHTML=this.data.map(item=>{const label=item.name||`Item ${this.data.indexOf(item) + 1}`;const formattedValue=this.forge.formatNumber(item.value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);return `
                <div style="display: flex; align-items: center; margin-bottom: 8px; font-size: ${this.forge.currentDesign.fontSize}px; font-family: ${this.forge.currentDesign.fontFamily};">
                    <div style="width: 16px; height: 10px; background-color: ${item.color}; margin-right: 8px; border-radius: 2px;"></div>
                    <span style="color: ${this.forge.getDesignValue('textColor')};">${label}: ${formattedValue} (${item.percentage.toFixed(1)}%)</span>
                </div>
            `}).join('')}
hexToRgba(hex,alpha){if(!hex||!hex.startsWith('#'))return `rgba(0, 0, 0, ${alpha})`;const r=parseInt(hex.slice(1,3),16);const g=parseInt(hex.slice(3,5),16);const b=parseInt(hex.slice(5,7),16);return `rgba(${r}, ${g}, ${b}, ${alpha})`}
handleMouseMove(e){if(!this.options.showTooltip)return;const rect=this.canvas.getBoundingClientRect();const x=e.clientX-rect.left;const y=e.clientY-rect.top;const centerX=rect.width/2;const centerY=rect.height/2;const outerRadius=Math.min(centerX,centerY)*0.8;const innerRadius=outerRadius*(this.options.innerRadius||0);const distance=Math.sqrt((x-centerX)**2+(y-centerY)**2);const previousHover=this.hoveredSlice;this.hoveredSlice=-1;if(distance>=innerRadius&&distance<=outerRadius+8){let angle=Math.atan2(y-centerY,x-centerX);angle=angle-this.options.startAngle;if(angle<0)angle+=2*Math.PI;if(angle>=2*Math.PI)angle-=2*Math.PI;const hoveredSliceIndex=this.currentAngles.findIndex((slice)=>{let start=slice.start-this.options.startAngle;let end=slice.end-this.options.startAngle;if(start<0)start+=2*Math.PI;if(end<0)end+=2*Math.PI;if(start>=2*Math.PI)start-=2*Math.PI;if(end>=2*Math.PI)end-=2*Math.PI;if(end<start){return angle>=start||angle<=end}
return angle>=start&&angle<=end});if(hoveredSliceIndex!==-1){this.hoveredSlice=hoveredSliceIndex;this.showTooltip(e,this.currentAngles[hoveredSliceIndex].item)}else{this.hideTooltip()}}else{this.hideTooltip()}
if(previousHover!==this.hoveredSlice){this.draw()}}
showTooltip(e,item){if(!this.tooltip)return;const label=item.name||`Item ${this.data.indexOf(item) + 1}`;const formattedValue=this.forge.formatNumber(item.value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);this.tooltip.innerHTML=`
            <div>
                <div style="font-weight: 600; margin-bottom: 2px;">${label}</div>
                <div>Value: ${formattedValue}</div>
                <div>Percentage: ${item.percentage.toFixed(1)}%</div>
            </div>
        `;this.tooltip.style.display='block';const offsetX=e.offsetX+10;const offsetY=e.offsetY-10;this.tooltip.style.left=`${offsetX}px`;this.tooltip.style.top=`${offsetY}px`;const tooltipRect=this.tooltip.getBoundingClientRect();const canvasRect=this.canvas.getBoundingClientRect();if(offsetX+tooltipRect.width>canvasRect.width){this.tooltip.style.left=`${offsetX - tooltipRect.width - 10}px`}
if(offsetY-tooltipRect.height<0){this.tooltip.style.top=`${offsetY + 20}px`}}
hideTooltip(){if(this.tooltip){this.tooltip.style.display='none'}}
redraw(){this.updateContainerBackground();this.draw();this.updateLegend()}
destroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
window.removeEventListener('resize',this.setupCanvas);this.canvas.removeEventListener('mousemove',this.handleMouseMove);this.canvas.removeEventListener('mouseleave',this.hideTooltip)}}
class ChartForgeColumn{constructor(containerId,options={},forge){this.container=document.getElementById(containerId);if(!this.container)throw new Error(`Container with ID '${containerId}' not found`);this.forge=forge;this.canvas=null;this.ctx=null;this.data=[];this.options={showGrid:!0,showLabels:!0,showTooltip:!0,showValues:!0,columnSpacing:0.2,groupSpacing:0.1,padding:{top:40,right:40,bottom:60,left:60},showLegend:!1,useKFormat:!1,valueAxisMin:0,valueAxisMax:null,valuePrefix:'',valueAfterfix:'',stacked:!1,customStart:!1,customStartValue:0,...options};this.tooltip=null;this.animationFrame=null;this.currentHeights=[];this.targetHeights=[];this.animationProgress=0;this.hoveredColumn={index:-1,subIndex:-1};this.chartContainer=null;this.legendContainer=null;this.padding=this.options.padding;this.init();this.setupEventListeners()}
init(){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';this.container.innerHTML=`
            <div class="chartforge-column-container" style="width: 100%; height: 100%; position: relative; background: ${this.forge.getDesignValue('background')};">
                <canvas style="width: 100%; height: 100%;"></canvas>
                <div class="chartforge-tooltip" style="position: absolute; display: none; background: rgba(17, 24, 39, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);"></div>
                <div class="chartforge-legend" style="position: absolute; top: 20px; right: 20px; background: ${legendBackground}; padding: 16px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); max-width: 200px; z-index: 1000; display: ${this.options.showLegend ? 'block' : 'none'};">
                    <div class="legend-items"></div>
                </div>
            </div>
        `;this.chartContainer=this.container.querySelector('.chartforge-column-container');this.canvas=this.container.querySelector('canvas');this.ctx=this.canvas.getContext('2d');this.tooltip=this.container.querySelector('.chartforge-tooltip');this.legendContainer=this.container.querySelector('.legend-items');this.setupCanvas()}
updateContainerBackground(){if(this.chartContainer){this.chartContainer.style.background=this.forge.getDesignValue('background')}
const legendElement=this.container.querySelector('.chartforge-legend');if(legendElement){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';legendElement.style.background=legendBackground}}
setupCanvas(){const resizeCanvas=()=>{const rect=this.canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;this.canvas.width=rect.width*dpr;this.canvas.height=rect.height*dpr;this.ctx.scale(dpr,dpr);this.canvas.style.width=rect.width+'px';this.canvas.style.height=rect.height+'px';this.calculateHeights();this.draw()};resizeCanvas();window.addEventListener('resize',resizeCanvas)}
setupEventListeners(){this.canvas.addEventListener('mousemove',(e)=>this.handleMouseMove(e));this.canvas.addEventListener('mouseleave',()=>this.hideTooltip());const observer=new MutationObserver(()=>{this.redraw()});observer.observe(document.documentElement,{attributes:!0,attributeFilter:['class']})}
calculateDynamicPadding(){const{top,right,bottom,left}=this.options.padding;let maxValueTextWidth=left;let maxLabelTextHeight=bottom;if(this.data.length===0)return{top,right,bottom,left};let allValues=[];let allLabels=[];this.data.forEach(item=>{if(Array.isArray(item.value)){allValues.push(...item.value.map(val=>this.forge.validateNumber(val)));allLabels.push(item.name||`Item ${allLabels.length + 1}`)}else{allValues.push(this.forge.validateNumber(item.value));allLabels.push(item.name||`Item ${allLabels.length + 1}`)}});const minValue=this.options.customStart?this.forge.validateNumber(this.options.customStartValue):this.forge.validateNumber(this.options.valueAxisMin);let maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):(allValues.length>0?Math.max(...allValues):1);if(this.options.stacked&&allValues.length>0){const stackedMax=Math.max(...this.data.map(item=>Array.isArray(item.value)?item.value.reduce((sum,val)=>sum+this.forge.validateNumber(val),0):this.forge.validateNumber(item.value)));maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):stackedMax}
this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;const steps=5;for(let i=0;i<=steps;i++){const value=minValue+((maxValue-minValue)/steps)*i;const text=this.forge.formatNumber(value,this.options.useKFormat,this.data[0]?.valuePrefix||this.options.valuePrefix,this.data[0]?.valueAfterfix||this.options.valueAfterfix);const textWidth=this.ctx.measureText(text).width;maxValueTextWidth=Math.max(maxValueTextWidth,textWidth+20)}
this.ctx.font=`${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;for(const label of allLabels){const textWidth=this.ctx.measureText(label).width;maxLabelTextHeight=Math.max(maxLabelTextHeight,textWidth+20)}
return{top,right,bottom:maxLabelTextHeight,left:maxValueTextWidth}}
setData(data){this.data=data.map((item,index)=>({...item,color:item.color||(Array.isArray(item.value)?this.forge.currentDesign.colors.slice(0,item.value.length):this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length]),valuePrefix:item.valuePrefix||this.options.valuePrefix,valueAfterfix:item.valueAfterfix||this.options.valueAfterfix}));this.calculateHeights();if(this.options.animations){this.animate()}else{this.currentHeights=[...this.targetHeights];this.draw()}
this.updateLegend()}
calculateHeights(){const allValues=this.data.flatMap(item=>Array.isArray(item.value)?item.value:[item.value]).map(val=>this.forge.validateNumber(val));const minValue=this.options.customStart?this.forge.validateNumber(this.options.customStartValue):this.forge.validateNumber(this.options.valueAxisMin);let maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):(allValues.length>0?Math.max(...allValues):1);if(this.options.stacked&&allValues.length>0){const stackedMax=Math.max(...this.data.map(item=>Array.isArray(item.value)?item.value.reduce((sum,val)=>sum+this.forge.validateNumber(val),0):this.forge.validateNumber(item.value)));maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):stackedMax}
const valueRange=maxValue-minValue||1;this.padding=this.calculateDynamicPadding();this.targetHeights=this.data.map(item=>{if(Array.isArray(item.value)){return{...item,normalizedHeights:item.value.map(val=>(this.forge.validateNumber(val)-minValue)/valueRange)}}else{return{...item,normalizedHeight:(this.forge.validateNumber(item.value)-minValue)/valueRange}}});if(this.currentHeights.length===0){this.currentHeights=this.targetHeights.map(item=>{if(item.normalizedHeights){return{...item,normalizedHeights:item.normalizedHeights.map(()=>0)}}else{return{...item,normalizedHeight:0}}})}}
animate(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
this.animationProgress=0;const startTime=Date.now();const animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/this.forge.currentDesign.animationDuration,1);if(this.animationProgress>=1){this.currentHeights=[...this.targetHeights]}else{const easeProgress=this.forge.easeInOutCubic(this.animationProgress);this.currentHeights=this.targetHeights.map((target,index)=>{const current=this.currentHeights[index]||target;if(target.normalizedHeights){return{...target,normalizedHeights:target.normalizedHeights.map((targetHeight,i)=>{const currentHeight=current.normalizedHeights?current.normalizedHeights[i]||0:0;return currentHeight+(targetHeight-currentHeight)*easeProgress})}}else{const currentHeight=current.normalizedHeight||0;return{...target,normalizedHeight:currentHeight+(target.normalizedHeight-currentHeight)*easeProgress}}})}
this.draw();if(this.animationProgress<1){this.animationFrame=requestAnimationFrame(animate)}};animate()}
draw(){const rect=this.canvas.getBoundingClientRect();const{top,right,bottom,left}=this.padding;const chartWidth=rect.width-left-right;const chartHeight=rect.height-top-bottom;this.ctx.clearRect(0,0,rect.width,rect.height);if(this.data.length===0){this.drawEmptyState(rect.width/2,rect.height/2);return}
if(this.options.showGrid){this.drawGrid(left,top,chartWidth,chartHeight)}
const columnWidth=chartWidth/(this.data.length+(this.data.length+1)*this.options.columnSpacing);const spacing=columnWidth*this.options.columnSpacing;this.currentHeights.forEach((item,index)=>{const x=left+spacing+index*(columnWidth+spacing);if(item.normalizedHeights){this.drawMultiColumn(x,top,columnWidth,chartHeight,item,index)}else{const columnHeight=chartHeight*item.normalizedHeight;const y=top+chartHeight-columnHeight;this.drawColumn(x,y,columnWidth,columnHeight,item,index)}});this.drawAxes(left,top,chartWidth,chartHeight);if(this.options.showLabels){this.drawLabels(left,top,chartWidth,chartHeight,columnWidth,spacing)}}
drawGrid(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('gridColor');this.ctx.lineWidth=1;this.ctx.setLineDash([2,4]);for(let i=0;i<=5;i++){const gridY=y+(height/5)*i;this.ctx.beginPath();this.ctx.moveTo(x,gridY);this.ctx.lineTo(x+width,gridY);this.ctx.stroke()}
this.ctx.setLineDash([])}
drawColumn(x,y,width,height,item,index){const isHovered=this.hoveredColumn.index===index;const adjustedHeight=isHovered?height+2:height;const adjustedY=isHovered?y-2:y;if(this.forge.currentDesign.glowEffect){this.ctx.shadowColor=item.color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;this.ctx.shadowOffsetX=0;this.ctx.shadowOffsetY=this.forge.currentDesign.shadowOffset}
const gradient=this.ctx.createLinearGradient(x,adjustedY,x,adjustedY+adjustedHeight);gradient.addColorStop(0,item.color);gradient.addColorStop(1,this.adjustColorBrightness(item.color,-0.2));this.ctx.fillStyle=gradient;this.drawRoundedRect(x,adjustedY,width,adjustedHeight,this.forge.currentDesign.borderRadius);this.ctx.fill();this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0;this.ctx.shadowOffsetY=0;this.ctx.strokeStyle=this.forge.getDesignValue('borderColor');this.ctx.lineWidth=1;this.ctx.stroke();if(isHovered){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.stroke()}
if(this.options.showValues){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontWeight} ${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='bottom';const formattedValue=this.forge.formatNumber(item.value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);this.ctx.fillText(formattedValue,x+width/2,adjustedY-5)}}
drawMultiColumn(x,top,width,chartHeight,item,index){const subColumnWidth=this.options.stacked?width:width/item.normalizedHeights.length;let stackY=top+chartHeight;item.normalizedHeights.forEach((height,subIndex)=>{const columnHeight=chartHeight*height;let columnY=stackY-columnHeight;if(!this.options.stacked){columnY=top+chartHeight-columnHeight}
const subX=this.options.stacked?x:x+subIndex*subColumnWidth;const subWidth=this.options.stacked?width:subColumnWidth;const color=Array.isArray(item.color)?item.color[subIndex]:item.color;const isHovered=this.hoveredColumn.index===index&&this.hoveredColumn.subIndex===subIndex;const adjustedHeight=isHovered?columnHeight+2:columnHeight;const adjustedY=isHovered?columnY-2:columnY;if(this.forge.currentDesign.glowEffect){this.ctx.shadowColor=color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;this.ctx.shadowOffsetX=0;this.ctx.shadowOffsetY=this.forge.currentDesign.shadowOffset}
const gradient=this.ctx.createLinearGradient(subX,adjustedY,subX,adjustedY+adjustedHeight);gradient.addColorStop(0,color);gradient.addColorStop(1,this.adjustColorBrightness(color,-0.2));this.ctx.fillStyle=gradient;this.drawRoundedRect(subX,adjustedY,subWidth,adjustedHeight,this.forge.currentDesign.borderRadius);this.ctx.fill();this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0;this.ctx.shadowOffsetY=0;this.ctx.strokeStyle=this.forge.getDesignValue('borderColor');this.ctx.lineWidth=1;this.ctx.stroke();if(isHovered){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.stroke()}
if(this.options.showValues){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontWeight} ${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='bottom';const formattedValue=this.forge.formatNumber(item.value[subIndex],this.options.useKFormat,item.valuePrefix,item.valueAfterfix);this.ctx.fillText(formattedValue,subX+subWidth/2,adjustedY-5)}
if(this.options.stacked){stackY=columnY}})}
drawRoundedRect(x,y,width,height,radius){this.ctx.beginPath();this.ctx.moveTo(x+radius,y);this.ctx.lineTo(x+width-radius,y);this.ctx.quadraticCurveTo(x+width,y,x+width,y+radius);this.ctx.lineTo(x+width,y+height-radius);this.ctx.quadraticCurveTo(x+width,y+height,x+width-radius,y+height);this.ctx.lineTo(x+radius,y+height);this.ctx.quadraticCurveTo(x,y+height,x,y+height-radius);this.ctx.lineTo(x,y+radius);this.ctx.quadraticCurveTo(x,y,x+radius,y);this.ctx.closePath()}
adjustColorBrightness(color,amount){const usePound=color[0]==='#';const col=usePound?color.slice(1):color;const num=parseInt(col,16);let r=(num>>16)+amount*255;let g=((num>>8)&0x00FF)+amount*255;let b=(num&0x0000FF)+amount*255;r=Math.max(0,Math.min(255,r));g=Math.max(0,Math.min(255,g));b=Math.max(0,Math.min(255,b));return(usePound?'#':'')+(r<<16|g<<8|b).toString(16).padStart(6,'0')}
drawAxes(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.beginPath();this.ctx.moveTo(x,y);this.ctx.lineTo(x,y+height);this.ctx.moveTo(x,y+height);this.ctx.lineTo(x+width,y+height);this.ctx.stroke();this.drawValueAxis(x,y,width,height)}
drawValueAxis(x,y,width,height){const allValues=this.data.flatMap(item=>Array.isArray(item.value)?item.value:[item.value]).map(val=>this.forge.validateNumber(val));const minValue=this.options.customStart?this.forge.validateNumber(this.options.customStartValue):this.forge.validateNumber(this.options.valueAxisMin);let maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):(allValues.length>0?Math.max(...allValues):1);if(this.options.stacked&&allValues.length>0){const stackedMax=Math.max(...this.data.map(item=>Array.isArray(item.value)?item.value.reduce((sum,val)=>sum+this.forge.validateNumber(val),0):this.forge.validateNumber(item.value)));maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):stackedMax}
const valueRange=maxValue-minValue||1;const steps=5;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;for(let i=0;i<=steps;i++){const value=minValue+((maxValue-minValue)/steps)*(steps-i);const axisY=y+(height/steps)*i;this.ctx.textAlign='right';this.ctx.textBaseline='middle';const formattedValue=this.forge.formatNumber(value,this.options.useKFormat,this.data[0].valuePrefix||this.options.valuePrefix,this.data[0].valueAfterfix||this.options.valueAfterfix);this.ctx.fillText(formattedValue,x-10,axisY)}}
drawLabels(x,y,width,height,columnWidth,spacing){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.data.forEach((item,index)=>{const labelX=x+spacing+index*(columnWidth+spacing)+columnWidth/2;this.ctx.textAlign='center';this.ctx.textBaseline='top';const label=item.name||`Item ${index + 1}`;this.ctx.fillText(label,labelX,y+height+15)})}
drawEmptyState(centerX,centerY){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize + 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('No Data Available',centerX,centerY)}
updateLegend(){if(!this.legendContainer)return;this.legendContainer.parentElement.style.display=this.options.showLegend?'block':'none';let legendItems=[];this.data.forEach((item,index)=>{if(Array.isArray(item.value)){item.value.forEach((value,subIndex)=>{const seriesName=item.seriesNames&&item.seriesNames[subIndex]?item.seriesNames[subIndex]:`Series ${subIndex + 1}`;const color=Array.isArray(item.color)?item.color[subIndex]:this.forge.currentDesign.colors[subIndex%this.forge.currentDesign.colors.length];legendItems.push(`
                        <div style="display: flex; align-items: center; margin-bottom: 8px; font-size: ${this.forge.currentDesign.fontSize}px; font-family: ${this.forge.currentDesign.fontFamily};">
                            <div style="width: 16px; height: 10px; background-color: ${color}; margin-right: 8px; border-radius: 2px;"></div>
                            <span style="color: ${this.forge.getDesignValue('textColor')};">${seriesName}</span>
                        </div>
                    `)})}else{legendItems.push(`
                    <div style="display: flex; align-items: center; margin-bottom: 8px; font-size: ${this.forge.currentDesign.fontSize}px; font-family: ${this.forge.currentDesign.fontFamily};">
                        <div style="width: 16px; height: 10px; background-color: ${item.color}; margin-right: 8px; border-radius: 2px;"></div>
                        <span style="color: ${this.forge.getDesignValue('textColor')};">${item.name || `Item ${index+1}`}</span>
                    </div>
                `)}});this.legendContainer.innerHTML=legendItems.join('')}
hexToRgba(hex,alpha){if(!hex||!hex.startsWith('#'))return `rgba(0, 0, 0, ${alpha})`;const r=parseInt(hex.slice(1,3),16);const g=parseInt(hex.slice(3,5),16);const b=parseInt(hex.slice(5,7),16);return `rgba(${r}, ${g}, ${b}, ${alpha})`}
handleMouseMove(e){if(!this.options.showTooltip)return;const rect=this.canvas.getBoundingClientRect();const mouseX=e.clientX-rect.left;const mouseY=e.clientY-rect.top;const{top,left}=this.padding;const chartWidth=rect.width-this.padding.left-this.padding.right;const chartHeight=rect.height-this.padding.top-this.padding.bottom;const previousHover={...this.hoveredColumn};this.hoveredColumn={index:-1,subIndex:-1};const columnWidth=chartWidth/(this.data.length+(this.data.length+1)*this.options.columnSpacing);const spacing=columnWidth*this.options.columnSpacing;this.currentHeights.forEach((item,index)=>{const x=left+spacing+index*(columnWidth+spacing);if(item.normalizedHeights){const subColumnWidth=this.options.stacked?columnWidth:columnWidth/item.normalizedHeights.length;let stackY=top+chartHeight;item.normalizedHeights.forEach((height,subIndex)=>{const columnHeight=chartHeight*height;let y=stackY-columnHeight;if(!this.options.stacked){y=top+chartHeight-columnHeight}
const subX=this.options.stacked?x:x+subIndex*subColumnWidth;if(mouseX>=subX&&mouseX<=subX+subColumnWidth&&mouseY>=y&&mouseY<=y+columnHeight){this.hoveredColumn={index,subIndex};this.showTooltip(e,item,subIndex)}
if(this.options.stacked){stackY=y}})}else{const columnHeight=chartHeight*item.normalizedHeight;const y=top+chartHeight-columnHeight;if(mouseX>=x&&mouseX<=x+columnWidth&&mouseY>=y&&mouseY<=y+columnHeight){this.hoveredColumn={index,subIndex:-1};this.showTooltip(e,item)}}});if(this.hoveredColumn.index===-1){this.hideTooltip()}
if(previousHover.index!==this.hoveredColumn.index||previousHover.subIndex!==this.hoveredColumn.subIndex){this.draw()}}
showTooltip(e,item,subIndex=-1){if(!this.tooltip)return;let value,seriesName,showSeriesName;if(subIndex>=0&&Array.isArray(item.value)){value=item.value[subIndex];seriesName=item.seriesNames&&item.seriesNames[subIndex]?item.seriesNames[subIndex]:`Series ${subIndex + 1}`;showSeriesName=!0}else{value=item.value;seriesName=item.name||'Data Point';showSeriesName=!1}
const formattedValue=this.forge.formatNumber(value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);const label=item.name||'Data Point';this.tooltip.innerHTML=`
            <div>
                ${showSeriesName ? `<div style="font-weight: 600; margin-bottom: 2px;">${seriesName}</div>` : ''}
                <div>${label}: ${formattedValue}</div>
            </div>
        `;this.tooltip.style.display='block';const offsetX=e.offsetX+10;const offsetY=e.offsetY-10;this.tooltip.style.left=`${offsetX}px`;this.tooltip.style.top=`${offsetY}px`;const tooltipRect=this.tooltip.getBoundingClientRect();const canvasRect=this.canvas.getBoundingClientRect();if(offsetX+tooltipRect.width>canvasRect.width){this.tooltip.style.left=`${offsetX - tooltipRect.width - 10}px`}
if(offsetY-tooltipRect.height<0){this.tooltip.style.top=`${offsetY + 20}px`}}
hideTooltip(){if(this.tooltip){this.tooltip.style.display='none'}}
redraw(){this.updateContainerBackground();this.calculateHeights();this.draw();this.updateLegend()}
destroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
window.removeEventListener('resize',this.setupCanvas);this.canvas.removeEventListener('mousemove',this.handleMouseMove);this.canvas.removeEventListener('mouseleave',this.hideTooltip)}}
class ChartForgeBar{constructor(containerId,options={},forge){this.container=document.getElementById(containerId);if(!this.container)throw new Error(`Container with ID '${containerId}' not found`);this.forge=forge;this.canvas=null;this.ctx=null;this.data=[];this.options={showGrid:!0,showLabels:!0,showTooltip:!0,showValues:!0,barSpacing:0.2,groupSpacing:0.1,padding:{top:40,right:80,bottom:40,left:120},showLegend:!1,useKFormat:!1,valueAxisMin:0,valueAxisMax:null,valuePrefix:'',valueAfterfix:'',stacked:!1,customStart:!1,customStartValue:0,...options};this.tooltip=null;this.animationFrame=null;this.currentWidths=[];this.targetWidths=[];this.animationProgress=0;this.hoveredBar={index:-1,subIndex:-1};this.chartContainer=null;this.legendContainer=null;this.padding=this.options.padding;this.init();this.setupEventListeners()}
init(){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';this.container.innerHTML=`
            <div class="chartforge-bar-container" style="width: 100%; height: 100%; position: relative; background: ${this.forge.getDesignValue('background')};">
                <canvas style="width: 100%; height: 100%;"></canvas>
                <div class="chartforge-tooltip" style="position: absolute; display: none; background: rgba(17, 24, 39, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);"></div>
                <div class="chartforge-legend" style="position: absolute; top: 20px; right: 20px; background: ${legendBackground}; padding: 16px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); max-width: 200px; z-index: 1000; display: ${this.options.showLegend ? 'block' : 'none'};">
                    <div class="legend-items"></div>
                </div>
            </div>
        `;this.chartContainer=this.container.querySelector('.chartforge-bar-container');this.canvas=this.container.querySelector('canvas');this.ctx=this.canvas.getContext('2d');this.tooltip=this.container.querySelector('.chartforge-tooltip');this.legendContainer=this.container.querySelector('.legend-items');this.setupCanvas()}
updateContainerBackground(){if(this.chartContainer){this.chartContainer.style.background=this.forge.getDesignValue('background')}
const legendElement=this.container.querySelector('.chartforge-legend');if(legendElement){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';legendElement.style.background=legendBackground}}
setupCanvas(){const resizeCanvas=()=>{const rect=this.canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;this.canvas.width=rect.width*dpr;this.canvas.height=rect.height*dpr;this.ctx.scale(dpr,dpr);this.canvas.style.width=rect.width+'px';this.canvas.style.height=rect.height+'px';this.calculateWidths();this.draw()};resizeCanvas();window.addEventListener('resize',resizeCanvas)}
setupEventListeners(){this.canvas.addEventListener('mousemove',(e)=>this.handleMouseMove(e));this.canvas.addEventListener('mouseleave',()=>this.hideTooltip());const observer=new MutationObserver(()=>{this.redraw()});observer.observe(document.documentElement,{attributes:!0,attributeFilter:['class']})}
calculateDynamicPadding(){const{top,right,bottom,left}=this.options.padding;let maxTextWidth=left;let maxTextHeight=bottom;this.ctx.font=`${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;if(this.data.length===0)return{top,right,bottom,left};let allValues=[];let allLabels=[];this.data.forEach(item=>{if(Array.isArray(item.value)){allValues.push(...item.value.map(val=>this.forge.validateNumber(val)));allLabels.push(item.name||`Item ${allLabels.length + 1}`)}else{allValues.push(this.forge.validateNumber(item.value));allLabels.push(item.name||`Item ${allLabels.length + 1}`)}});const minValue=this.options.customStart?this.forge.validateNumber(this.options.customStartValue):this.forge.validateNumber(this.options.valueAxisMin);let maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):(allValues.length>0?Math.max(...allValues):1);if(this.options.stacked&&allValues.length>0){const stackedMax=Math.max(...this.data.map(item=>Array.isArray(item.value)?item.value.reduce((sum,val)=>sum+this.forge.validateNumber(val),0):this.forge.validateNumber(item.value)));maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):stackedMax}
this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;const steps=5;for(let i=0;i<=steps;i++){const value=minValue+((maxValue-minValue)/steps)*i;const text=this.forge.formatNumber(value,this.options.useKFormat,this.options.valuePrefix||'',this.options.valueAfterfix||'');const textWidth=this.ctx.measureText(text).width;maxTextHeight=Math.max(maxTextHeight,textWidth+20)}
this.ctx.font=`${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;for(const label of allLabels){const textWidth=this.ctx.measureText(label).width;maxTextWidth=Math.max(maxTextWidth,textWidth+20)}
return{top,right,bottom:maxTextHeight,left:maxTextWidth}}
setData(data){this.data=data.map((item,index)=>({...item,color:item.color||(Array.isArray(item.value)?this.forge.currentDesign.colors.slice(0,item.value.length):this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length]),valuePrefix:item.valuePrefix||this.options.valuePrefix,valueAfterfix:item.valueAfterfix||this.options.valueAfterfix}));this.calculateWidths();if(this.options.animations){this.animate()}else{this.currentWidths=[...this.targetWidths];this.draw()}
this.updateLegend()}
calculateWidths(){const allValues=this.data.flatMap(item=>Array.isArray(item.value)?item.value:[item.value]).map(val=>this.forge.validateNumber(val));const minValue=this.options.customStart?this.forge.validateNumber(this.options.customStartValue):this.forge.validateNumber(this.options.valueAxisMin);let maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):(allValues.length>0?Math.max(...allValues):1);if(this.options.stacked&&allValues.length>0){const stackedMax=Math.max(...this.data.map(item=>Array.isArray(item.value)?item.value.reduce((sum,val)=>sum+this.forge.validateNumber(val),0):this.forge.validateNumber(item.value)));maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):stackedMax}
const valueRange=maxValue-minValue||1;this.padding=this.calculateDynamicPadding();this.targetWidths=this.data.map(item=>{if(Array.isArray(item.value)){return{...item,normalizedWidths:item.value.map(val=>(this.forge.validateNumber(val)-minValue)/valueRange)}}else{return{...item,normalizedWidth:(this.forge.validateNumber(item.value)-minValue)/valueRange}}});if(this.currentWidths.length===0){this.currentWidths=this.targetWidths.map(item=>{if(item.normalizedWidths){return{...item,normalizedWidths:item.normalizedWidths.map(()=>0)}}else{return{...item,normalizedWidth:0}}})}}
animate(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
this.animationProgress=0;const startTime=Date.now();const animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/this.forge.currentDesign.animationDuration,1);if(this.animationProgress>=1){this.currentWidths=[...this.targetWidths]}else{const easeProgress=this.forge.easeInOutCubic(this.animationProgress);this.currentWidths=this.targetWidths.map((target,index)=>{const current=this.currentWidths[index]||target;if(target.normalizedWidths){return{...target,normalizedWidths:target.normalizedWidths.map((width,i)=>{const currentWidth=current.normalizedWidths?current.normalizedWidths[i]||0:0;return currentWidth+(width-currentWidth)*easeProgress})}}else{const currentWidth=current.normalizedWidth||0;return{...target,normalizedWidth:currentWidth+(target.normalizedWidth-currentWidth)*easeProgress}}})}
this.draw();if(this.animationProgress<1){this.animationFrame=requestAnimationFrame(animate)}};animate()}
draw(){const rect=this.canvas.getBoundingClientRect();const{top,right,bottom,left}=this.padding;const chartWidth=rect.width-left-right;const chartHeight=rect.height-top-bottom;this.ctx.clearRect(0,0,rect.width,rect.height);if(this.data.length===0){this.drawEmptyState(rect.width/2,rect.height/2);return}
if(this.options.showGrid){this.drawGrid(left,top,chartWidth,chartHeight)}
const barHeight=chartHeight/(this.data.length+(this.data.length+1)*this.options.barSpacing);const spacing=barHeight*this.options.barSpacing;this.currentWidths.forEach((item,index)=>{const y=top+spacing+index*(barHeight+spacing);if(item.normalizedWidths){this.drawMultiBar(left,y,chartWidth,barHeight,item,index)}else{const barWidth=chartWidth*item.normalizedWidth;this.drawBar(left,y,barWidth,barHeight,item,index)}});this.drawAxes(left,top,chartWidth,chartHeight);if(this.options.showLabels){this.drawLabels(left,top,chartWidth,chartHeight,barHeight,spacing)}}
drawGrid(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('gridColor');this.ctx.lineWidth=1;this.ctx.setLineDash([2,4]);for(let i=0;i<=5;i++){const gridX=x+(width/5)*i;this.ctx.beginPath();this.ctx.moveTo(gridX,y);this.ctx.lineTo(gridX,y+height);this.ctx.stroke()}
this.ctx.setLineDash([])}
drawBar(x,y,width,height,item,index){const isHovered=this.hoveredBar.index===index&&this.hoveredBar.subIndex===-1;const adjustedWidth=isHovered?width+2:width;if(this.forge.currentDesign.glowEffect){this.ctx.shadowColor=item.color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;this.ctx.shadowOffsetX=this.forge.currentDesign.shadowOffset;this.ctx.shadowOffsetY=0}
const gradient=this.ctx.createLinearGradient(x,y,x+adjustedWidth,y);gradient.addColorStop(0,item.color);gradient.addColorStop(1,this.adjustColorBrightness(item.color,-0.2));this.ctx.fillStyle=gradient;this.drawRoundedRect(x,y,adjustedWidth,height,this.forge.currentDesign.borderRadius);this.ctx.fill();this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0;this.ctx.shadowOffsetX=0;this.ctx.strokeStyle=this.forge.getDesignValue('borderColor');this.ctx.lineWidth=1;this.ctx.stroke();if(isHovered){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.stroke()}
if(this.options.showValues){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontWeight} ${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='left';this.ctx.textBaseline='middle';const formattedValue=this.forge.formatNumber(item.value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);this.ctx.fillText(formattedValue,x+adjustedWidth+5,y+height/2)}}
drawMultiBar(x,y,maxWidth,height,item,index){const subBarHeight=this.options.stacked?height:height/item.normalizedWidths.length;let stackX=x;item.normalizedWidths.forEach((width,subIndex)=>{const barWidth=maxWidth*width;let barX=stackX;if(!this.options.stacked){barX=x}
const subY=this.options.stacked?y:y+subIndex*subBarHeight;const subHeight=this.options.stacked?height:subBarHeight;const color=Array.isArray(item.color)?item.color[subIndex]:item.color;const isHovered=this.hoveredBar.index===index&&this.hoveredBar.subIndex===subIndex;const adjustedWidth=isHovered?barWidth+2:barWidth;if(this.forge.currentDesign.glowEffect){this.ctx.shadowColor=color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;this.ctx.shadowOffsetX=this.forge.currentDesign.shadowOffset;this.ctx.shadowOffsetY=0}
const gradient=this.ctx.createLinearGradient(barX,subY,barX+adjustedWidth,subY);gradient.addColorStop(0,color);gradient.addColorStop(1,this.adjustColorBrightness(color,-0.2));this.ctx.fillStyle=gradient;this.drawRoundedRect(barX,subY,adjustedWidth,subHeight,this.forge.currentDesign.borderRadius);this.ctx.fill();this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0;this.ctx.shadowOffsetX=0;this.ctx.strokeStyle=this.forge.getDesignValue('borderColor');this.ctx.lineWidth=1;this.ctx.stroke();if(isHovered){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.stroke()}
if(this.options.showValues){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontWeight} ${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='left';this.ctx.textBaseline='middle';const formattedValue=this.forge.formatNumber(item.value[subIndex],this.options.useKFormat,item.valuePrefix,item.valueAfterfix);this.ctx.fillText(formattedValue,barX+adjustedWidth+5,subY+subHeight/2)}
if(this.options.stacked){stackX+=barWidth}})}
drawRoundedRect(x,y,width,height,radius){this.ctx.beginPath();this.ctx.moveTo(x+radius,y);this.ctx.lineTo(x+width-radius,y);this.ctx.quadraticCurveTo(x+width,y,x+width,y+radius);this.ctx.lineTo(x+width,y+height-radius);this.ctx.quadraticCurveTo(x+width,y+height,x+width-radius,y+height);this.ctx.lineTo(x+radius,y+height);this.ctx.quadraticCurveTo(x,y+height,x,y+height-radius);this.ctx.lineTo(x,y+radius);this.ctx.quadraticCurveTo(x,y,x+radius,y);this.ctx.closePath()}
adjustColorBrightness(color,amount){const usePound=color[0]==='#';const col=usePound?color.slice(1):color;const num=parseInt(col,16);let r=(num>>16)+amount*255;let g=((num>>8)&0x00FF)+amount*255;let b=(num&0x0000FF)+amount*255;r=Math.max(0,Math.min(255,r));g=Math.max(0,Math.min(255,g));b=Math.max(0,Math.min(255,b));return(usePound?'#':'')+(r<<16|g<<8|b).toString(16).padStart(6,'0')}
drawAxes(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.beginPath();this.ctx.moveTo(x,y);this.ctx.lineTo(x,y+height);this.ctx.moveTo(x,y+height);this.ctx.lineTo(x+width,y+height);this.ctx.stroke();this.drawValueAxis(x,y,width,height)}
drawValueAxis(x,y,width,height){const allValues=this.data.flatMap(item=>Array.isArray(item.value)?item.value:[item.value]).map(val=>this.forge.validateNumber(val));const minValue=this.options.customStart?this.forge.validateNumber(this.options.customStartValue):this.forge.validateNumber(this.options.valueAxisMin);let maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):(allValues.length>0?Math.max(...allValues):1);if(this.options.stacked&&allValues.length>0){const stackedMax=Math.max(...this.data.map(item=>Array.isArray(item.value)?item.value.reduce((sum,val)=>sum+this.forge.validateNumber(val),0):this.forge.validateNumber(item.value)));maxValue=this.options.valueAxisMax!==null?this.forge.validateNumber(this.options.valueAxisMax):stackedMax}
const valueRange=maxValue-minValue||1;const steps=5;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;for(let i=0;i<=steps;i++){const value=minValue+((maxValue-minValue)/steps)*i;const axisX=x+(width/steps)*i;this.ctx.textAlign='center';this.ctx.textBaseline='top';const formattedValue=this.forge.formatNumber(value,this.options.useKFormat,this.data[0].valuePrefix||this.options.valuePrefix,this.data[0].valueAfterfix||this.options.valueAfterfix);this.ctx.fillText(formattedValue,axisX,y+height+10)}}
drawLabels(x,y,width,height,barHeight,spacing){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.data.forEach((item,index)=>{const labelY=y+spacing+index*(barHeight+spacing)+barHeight/2;this.ctx.textAlign='right';this.ctx.textBaseline='middle';const label=item.name||`Item ${index + 1}`;this.ctx.fillText(label,x-10,labelY)})}
drawEmptyState(centerX,centerY){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize + 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('No Data Available',centerX,centerY)}
updateLegend(){if(!this.legendContainer)return;this.legendContainer.parentElement.style.display=this.options.showLegend?'block':'none';let legendItems=[];this.data.forEach((item,index)=>{if(Array.isArray(item.value)){item.value.forEach((value,subIndex)=>{const seriesName=item.seriesNames&&item.seriesNames[subIndex]?item.seriesNames[subIndex]:`Series ${subIndex + 1}`;const color=Array.isArray(item.color)?item.color[subIndex]:this.forge.currentDesign.colors[subIndex%this.forge.currentDesign.colors.length];legendItems.push(`
                        <div style="display: flex; align-items: center; margin-bottom: 8px; font-size: ${this.forge.currentDesign.fontSize}px; font-family: ${this.forge.currentDesign.fontFamily};">
                            <div style="width: 16px; height: 10px; background-color: ${color}; margin-right: 8px; border-radius: 2px;"></div>
                            <span style="color: ${this.forge.getDesignValue('textColor')};">${seriesName}</span>
                        </div>
                    `)})}else{legendItems.push(`
                    <div style="display: flex; align-items: center; margin-bottom: 8px; font-size: ${this.forge.currentDesign.fontSize}px; font-family: ${this.forge.currentDesign.fontFamily};">
                        <div style="width: 16px; height: 10px; background-color: ${item.color}; margin-right: 8px; border-radius: 2px;"></div>
                        <span style="color: ${this.forge.getDesignValue('textColor')};">${item.name || `Item ${index+1}`}</span>
                    </div>
                `)}});this.legendContainer.innerHTML=legendItems.join('')}
hexToRgba(hex,alpha){if(!hex||!hex.startsWith('#'))return `rgba(0, 0, 0, ${alpha})`;const r=parseInt(hex.slice(1,3),16);const g=parseInt(hex.slice(3,5),16);const b=parseInt(hex.slice(5,7),16);return `rgba(${r}, ${g}, ${b}, ${alpha})`}
handleMouseMove(e){if(!this.options.showTooltip)return;const rect=this.canvas.getBoundingClientRect();const mouseX=e.clientX-rect.left;const mouseY=e.clientY-rect.top;const{top,left}=this.padding;const chartWidth=rect.width-this.padding.left-this.padding.right;const chartHeight=rect.height-this.padding.top-this.padding.bottom;const previousHover={...this.hoveredBar};this.hoveredBar={index:-1,subIndex:-1};const barHeight=chartHeight/(this.data.length+(this.data.length+1)*this.options.barSpacing);const spacing=barHeight*this.options.barSpacing;this.currentWidths.forEach((item,index)=>{const barY=top+spacing+index*(barHeight+spacing);if(item.normalizedWidths){const subBarHeight=this.options.stacked?barHeight:barHeight/item.normalizedWidths.length;let stackX=left;item.normalizedWidths.forEach((width,subIndex)=>{const barWidth=chartWidth*width;let barX=stackX;const subY=this.options.stacked?barY:barY+subIndex*subBarHeight;const subHeight=this.options.stacked?barHeight:subBarHeight;if(!this.options.stacked){barX=left}
if(mouseX>=barX&&mouseX<=barX+barWidth&&mouseY>=subY&&mouseY<=subY+subHeight){this.hoveredBar={index,subIndex};this.showTooltip(e,item,subIndex)}
if(this.options.stacked){stackX+=barWidth}})}else{const barWidth=chartWidth*item.normalizedWidth;if(mouseX>=left&&mouseX<=left+barWidth&&mouseY>=barY&&mouseY<=barY+barHeight){this.hoveredBar={index,subIndex:-1};this.showTooltip(e,item)}}});if(this.hoveredBar.index===-1){this.hideTooltip()}
if(previousHover.index!==this.hoveredBar.index||previousHover.subIndex!==this.hoveredBar.subIndex){this.draw()}}
showTooltip(e,item,subIndex=-1){if(!this.tooltip)return;let value,seriesName,showSeriesName;if(subIndex>=0&&Array.isArray(item.value)){value=item.value[subIndex];seriesName=item.seriesNames&&item.seriesNames[subIndex]?item.seriesNames[subIndex]:`Series ${subIndex + 1}`;showSeriesName=!0}else{value=item.value;seriesName=item.name||'Data Point';showSeriesName=!1}
const formattedValue=this.forge.formatNumber(value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);const label=item.name||'Data Point';this.tooltip.innerHTML=`
            <div>
                ${showSeriesName ? `<div style="font-weight: 600; margin-bottom: 2px;">${seriesName}</div>` : ''}
                <div>${label}: ${formattedValue}</div>
            </div>
        `;this.tooltip.style.display='block';const offsetX=e.offsetX+10;const offsetY=e.offsetY-10;this.tooltip.style.left=`${offsetX}px`;this.tooltip.style.top=`${offsetY}px`;const tooltipRect=this.tooltip.getBoundingClientRect();const canvasRect=this.canvas.getBoundingClientRect();if(offsetX+tooltipRect.width>canvasRect.width){this.tooltip.style.left=`${offsetX - tooltipRect.width - 10}px`}
if(offsetY-tooltipRect.height<0){this.tooltip.style.top=`${offsetY + 20}px`}}
hideTooltip(){if(this.tooltip){this.tooltip.style.display='none'}}
redraw(){this.updateContainerBackground();this.calculateWidths();this.draw();this.updateLegend()}
destroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
window.removeEventListener('resize',this.setupCanvas);this.canvas.removeEventListener('mousemove',this.handleMouseMove);this.canvas.removeEventListener('mouseleave',this.hideTooltip)}}
class ChartForgeLine{constructor(containerId,options={},forge){this.container=document.getElementById(containerId);if(!this.container)throw new Error(`Container with ID '${containerId}' not found`);this.forge=forge;this.canvas=null;this.ctx=null;this.data=[];this.options={showGrid:!0,showLabels:!0,showTooltip:!0,showPoints:!0,showValues:!1,lineWidth:3,pointRadius:4,tension:0.5,padding:{top:40,right:40,bottom:60,left:60},multiSeries:!1,showLegend:!0,useKFormat:!1,showZoom:!1,showZoomTool:!1,zoomRangeStart:0,zoomRangeEnd:0,scrollSpeedMultiplier:1.0,moveSpeedMultiplier:1.0,valuePrefix:'',valueAfterfix:'',showAdvancedTooltip:!1,pinchZoomSensitivity:0.05,...options};this.tooltip=null;this.animationFrame=null;this.currentProgress=0;this.targetProgress=1;this.animationProgress=0;this.hoveredPoint={seriesIndex:-1,pointIndex:-1};this.pathCache=[];this.chartContainer=null;this.legendContainer=null;this.zoomLevel=1;this.zoomStart=0;this.zoomEnd=1;this.zoomHandles={left:this.zoomStart,right:this.zoomEnd};this.isDragging={left:!1,right:!1,range:!1};this.isCanvasDragging=!1;this.isAxisDragging=!1;this.dragStartX=null;this.dragStartY=null;this.initialValueAxisMin=0;this.initialValueAxisMax=null;this.minHandleOffset=0.01;this.pinchStartDistance=null;this.pinchCenterX=null;this.padding=this.options.padding;this.globalMin=0;this.globalMax=1;this.hasNegative=!1;this.lowestAllowedMin=0;this.init();this.setupEventListeners()}
normalizeZoomIndex(index,totalPoints){if(totalPoints<=1)return index;return Math.max(0,Math.min(1,index/(totalPoints-1)))}
updateZoomRange(startIndex,endIndex,totalPoints){if(totalPoints<=1){this.zoomStart=0;this.zoomEnd=1}else{const normalizedStart=this.normalizeZoomIndex(startIndex,totalPoints);const normalizedEnd=this.normalizeZoomIndex(endIndex,totalPoints);this.zoomStart=Math.max(0+this.minHandleOffset,Math.min(normalizedStart,1-this.minHandleOffset));this.zoomEnd=Math.max(0+this.minHandleOffset,Math.min(normalizedEnd,1-this.minHandleOffset));if(this.zoomStart>this.zoomEnd){[this.zoomStart,this.zoomEnd]=[this.zoomEnd,this.zoomStart]}}
this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.calculatePaths();this.redraw();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}
init(){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';const primaryColor=this.forge.currentDesign.colors[0]||'#3B82F6';const zoomRangeColor=this.getZoomRangeColor(primaryColor);this.container.innerHTML=`
            <div class="chartforge-line-container" style="width: 100%; height: 100%; position: relative; background: ${this.forge.getDesignValue('background')};">
                <canvas style="width: 100%; height: 100%;"></canvas>
                ${this.options.showZoomTool ? `<div class="chartforge-zoom-tool" style="position: absolute; top: 10px; left: 60px; right: 60px; height: 20px; background: ${this.forge.getDesignValue('gridColor')}; border-radius: 10px; overflow: hidden; z-index: 10;"><div class="zoom-range" style="position: absolute; top: 0; bottom: 0; background: ${zoomRangeColor}; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);"></div><div class="zoom-handle left-handle" style="position: absolute; top: 0; bottom: 0; width: 10px; background: ${this.forge.getDesignValue('textColor')}; cursor: ew-resize; z-index: 11;"></div><div class="zoom-handle right-handle" style="position: absolute; top: 0; bottom: 0; width: 10px; background: ${this.forge.getDesignValue('textColor')}; cursor: ew-resize; z-index: 11;"></div></div>` : ''}
                <div class="chartforge-tooltip" style="position: absolute; display: none; background: rgba(17, 24, 39, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></div>
                ${this.options.showLegend ? `<div class="chartforge-legend" style="position: absolute; top: ${this.options.showZoomTool ? '40px' : '20px'}; right: 20px; background: ${legendBackground}; padding: 16px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); max-width: 200px;"><div class="legend-items"></div></div>` : ''}
            </div>
        `;this.chartContainer=this.container.querySelector('.chartforge-line-container');this.canvas=this.container.querySelector('canvas');this.ctx=this.canvas.getContext('2d');this.tooltip=this.container.querySelector('.chartforge-tooltip');this.legendContainer=this.container.querySelector('.legend-items');this.zoomTool=this.container.querySelector('.chartforge-zoom-tool');this.zoomRange=this.container.querySelector('.zoom-range');this.leftHandle=this.container.querySelector('.left-handle');this.rightHandle=this.container.querySelector('.right-handle');this.setupCanvas();this.setupZoom()}
getPrimaryChartColor(){if(this.data&&this.data.length>0&&this.data[0].color){return this.data[0].color}
return this.forge.currentDesign.colors[0]||'#3B82F6'}
getZoomRangeColor(primaryColor){const hex=primaryColor.replace('#','');const r=parseInt(hex.substr(0,2),16);const g=parseInt(hex.substr(2,2),16);const b=parseInt(hex.substr(4,2),16);return `rgba(${r}, ${g}, ${b}, 0.15)`}
updateContainerBackground(){if(this.chartContainer){this.chartContainer.style.background=this.forge.getDesignValue('background')}
const legendElement=this.container.querySelector('.chartforge-legend');if(legendElement){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';legendElement.style.background=legendBackground}}
setupCanvas(){const resizeCanvas=()=>{const rect=this.canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;this.canvas.width=rect.width*dpr;this.canvas.height=rect.height*dpr;this.ctx.scale(dpr,dpr);this.canvas.style.width=rect.width+'px';this.canvas.style.height=rect.height+'px';this.calculatePaths();this.redraw(!1)};resizeCanvas();window.addEventListener('resize',resizeCanvas)}
setupZoom(){if(!this.options.showZoom||!this.zoomTool)return;this.updateZoomHandles();const startDrag=(e,handle)=>{e.preventDefault();this.isDragging[handle]=!0;const rect=this.zoomTool.getBoundingClientRect();const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;const minZoomRange=totalPoints>1?1/(totalPoints-1):0;const moveHandler=(moveEvent)=>{if(!this.isDragging[handle])return;const clientX=moveEvent.type.includes('touch')?moveEvent.touches[0].clientX:moveEvent.clientX;const newX=clientX-rect.left;let percentage=Math.max(0,Math.min(100,(newX/rect.width)*100))/100;if(handle==='left'){percentage=Math.max(this.minHandleOffset,Math.min(percentage,this.zoomHandles.right-minZoomRange));this.zoomHandles.left=percentage}else if(handle==='right'){percentage=Math.min(1-this.minHandleOffset,Math.max(percentage,this.zoomHandles.left+minZoomRange));this.zoomHandles.right=percentage}else if(handle==='range'){const rangeWidth=this.zoomHandles.right-this.zoomHandles.left;const center=percentage;let newLeft=center-rangeWidth/2;let newRight=center+rangeWidth/2;if(newLeft<this.minHandleOffset){newLeft=this.minHandleOffset;newRight=newLeft+rangeWidth}else if(newRight>1-this.minHandleOffset){newRight=1-this.minHandleOffset;newLeft=newRight-rangeWidth}
this.zoomHandles.left=newLeft;this.zoomHandles.right=newRight}
this.zoomStart=this.zoomHandles.left;this.zoomEnd=this.zoomHandles.right;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.calculatePaths();this.redraw();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}};const stopDrag=()=>{this.isDragging[handle]=!1;window.removeEventListener('mousemove',moveHandler);window.removeEventListener('touchmove',moveHandler);window.removeEventListener('mouseup',stopDrag);window.removeEventListener('touchend',stopDrag);if(handle==='range'){this.zoomRange.style.cursor='grab'}};window.addEventListener('mousemove',moveHandler);window.addEventListener('touchmove',moveHandler,{passive:!1});window.addEventListener('mouseup',stopDrag);window.addEventListener('touchend',stopDrag)};this.leftHandle.addEventListener('mousedown',(e)=>startDrag(e,'left'));this.leftHandle.addEventListener('touchstart',(e)=>startDrag(e,'left'),{passive:!1});this.rightHandle.addEventListener('mousedown',(e)=>startDrag(e,'right'));this.rightHandle.addEventListener('touchstart',(e)=>startDrag(e,'right'),{passive:!1});if(this.zoomRange){this.zoomRange.style.cursor='grab';this.zoomRange.addEventListener('mousedown',(e)=>{if(e.target===this.leftHandle||e.target===this.rightHandle)return;this.zoomRange.style.cursor='grabbing';startDrag(e,'range')});this.zoomRange.addEventListener('touchstart',(e)=>{if(e.target===this.leftHandle||e.target===this.rightHandle)return;this.zoomRange.style.cursor='grabbing';startDrag(e,'range')},{passive:!1})}}
updateZoomHandles(){if(!this.zoomTool||!this.options.showZoomTool)return;this.leftHandle.style.left=`${Math.max(this.minHandleOffset * 100, Math.min(100 - this.minHandleOffset * 100, this.zoomHandles.left * 100))}%`;this.rightHandle.style.left=`${Math.max(this.minHandleOffset * 100, Math.min(100 - this.minHandleOffset * 100, this.zoomHandles.right * 100))}%`;this.zoomRange.style.left=`${this.zoomHandles.left * 100}%`;this.zoomRange.style.width=`${(this.zoomHandles.right - this.zoomHandles.left) * 100}%`}
setupEventListeners(){const startCanvasDrag=(e)=>{e.preventDefault();const rect=this.canvas.getBoundingClientRect();const clientX=e.type.includes('touch')?e.touches[0].clientX:e.clientX;const clientY=e.type.includes('touch')?e.touches[0].clientY:e.clientY;const mouseX=clientX-rect.left;const mouseY=clientY-rect.top;const{left}=this.padding;if(mouseX<=left&&mouseY>=this.padding.top&&mouseY<=rect.height-this.padding.bottom){this.isAxisDragging=!0;this.dragStartY=clientY;this.initialValueAxisMin=this.options.valueAxisMin;this.initialValueAxisMax=this.options.valueAxisMax;this.canvas.style.cursor='ns-resize';this.hideTooltip()}else{this.isCanvasDragging=!0;this.dragStartX=clientX;this.dragStartY=clientY;this.canvas.style.cursor='grabbing'}
if(e.type.includes('touch')&&this.options.showTooltip){this.handleMouseMove(e)}};const moveCanvas=(e)=>{e.preventDefault();const clientX=e.type.includes('touch')?e.touches[0].clientX:e.clientX;const clientY=e.type.includes('touch')?e.touches[0].clientY:e.clientY;if(this.isAxisDragging){const rect=this.canvas.getBoundingClientRect();const deltaY=clientY-this.dragStartY;const chartHeight=rect.height-this.padding.top-this.padding.bottom;const sensitivity=1.5;const midPrice=(this.initialValueAxisMin+this.initialValueAxisMax)/2;const initialRange=this.initialValueAxisMax-this.initialValueAxisMin;const scaleFactor=1+(deltaY/chartHeight)*sensitivity;let newRange=initialRange*scaleFactor;let newMin=midPrice-newRange/2;let newMax=midPrice+newRange/2;if(newMin<this.lowestAllowedMin){newMin=this.lowestAllowedMin;newMax=newMin+newRange}
this.options.valueAxisMin=newMin;this.options.valueAxisMax=newMax;this.calculatePaths();this.redraw()}else if(this.isCanvasDragging){const rect=this.canvas.getBoundingClientRect();const deltaX=clientX-this.dragStartX;const deltaY=clientY-this.dragStartY;const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;const chartWidth=rect.width-this.padding.left-this.padding.right;const chartHeight=rect.height-this.padding.top-this.padding.bottom;const range=this.zoomEnd-this.zoomStart;const horizontalShift=(deltaX/chartWidth)*range*this.options.moveSpeedMultiplier;const valueRange=this.options.valueAxisMax-this.options.valueAxisMin;const verticalShift=(deltaY/chartHeight)*valueRange*this.options.moveSpeedMultiplier;let newZoomStart=this.zoomStart-horizontalShift;let newZoomEnd=this.zoomEnd-horizontalShift;newZoomStart=Math.max(0,Math.min(newZoomStart,1-range));newZoomEnd=newZoomStart+range;this.zoomStart=newZoomStart;this.zoomEnd=newZoomEnd;this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.options.valueAxisMin+=verticalShift;this.options.valueAxisMax+=verticalShift;if(this.options.valueAxisMin<this.lowestAllowedMin){const diff=this.lowestAllowedMin-this.options.valueAxisMin;this.options.valueAxisMin+=diff;this.options.valueAxisMax+=diff}
this.dragStartX=clientX;this.dragStartY=clientY;this.calculatePaths();this.redraw();if(this.options.showTooltip&&e.type.includes('touch')){this.handleMouseMove(e)}
if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}else{const rect=this.canvas.getBoundingClientRect();const mouseX=clientX-rect.left;const mouseY=clientY-rect.top;const{left}=this.padding;if(mouseX<=left&&mouseY>=this.padding.top&&mouseY<=rect.height-this.padding.bottom){this.canvas.style.cursor='ns-resize'}else{this.canvas.style.cursor='default'}
if(!/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)){this.handleMouseMove(e)}}};const stopCanvasDrag=()=>{if(this.isAxisDragging){this.isAxisDragging=!1;this.canvas.style.cursor='default';this.dragStartY=null}
if(this.isCanvasDragging){this.isCanvasDragging=!1;this.canvas.style.cursor='default';this.dragStartX=null;this.dragStartY=null;this.hideTooltip()}};const handlePinch=(e)=>{e.preventDefault();if(!this.options.showZoom||e.touches.length!==2)return;const rect=this.canvas.getBoundingClientRect();const touch1={x:e.touches[0].clientX-rect.left,y:e.touches[0].clientY-rect.top};const touch2={x:e.touches[1].clientX-rect.left,y:e.touches[1].clientY-rect.top};if(touch1.x<this.padding.left||touch1.x>rect.width-this.padding.right||touch2.x<this.padding.left||touch2.x>rect.width-this.padding.right)return;const distance=Math.hypot(touch1.x-touch2.x,touch1.y-touch2.y);this.pinchCenterX=(touch1.x+touch2.x)/2;if(this.pinchStartDistance===null){this.pinchStartDistance=distance;return}
const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;const minZoomRange=totalPoints>1?1/(totalPoints-1):0;const currentRange=this.zoomEnd-this.zoomStart;const rawScaleFactor=this.pinchStartDistance/distance;const sensitivity=this.options.pinchZoomSensitivity||0.05;const scaleFactor=1+(rawScaleFactor-1)*sensitivity;let newRange=currentRange*scaleFactor;newRange=Math.max(minZoomRange,Math.min(1,newRange));const normalizedCenter=(this.pinchCenterX-this.padding.left)/(rect.width-this.padding.left-this.padding.right);const center=this.zoomStart+(this.zoomEnd-this.zoomStart)*normalizedCenter;let newZoomStart=center-(newRange/2);let newZoomEnd=center+(newRange/2);newZoomStart=Math.max(0,Math.min(newZoomStart,1-newRange));newZoomEnd=newZoomStart+newRange;this.zoomStart=newZoomStart;this.zoomEnd=newZoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.calculatePaths();this.redraw();this.hideTooltip();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}};this.canvas.addEventListener('mousedown',startCanvasDrag);this.canvas.addEventListener('touchstart',(e)=>{if(e.touches.length===1){startCanvasDrag(e)}else if(e.touches.length===2){this.pinchStartDistance=null;handlePinch(e)}},{passive:!1});this.canvas.addEventListener('mousemove',moveCanvas);this.canvas.addEventListener('touchmove',(e)=>{if(e.touches.length===1){moveCanvas(e)}else if(e.touches.length===2){handlePinch(e)}},{passive:!1});this.canvas.addEventListener('mouseup',stopCanvasDrag);this.canvas.addEventListener('touchend',(e)=>{this.pinchStartDistance=null;stopCanvasDrag()});this.canvas.addEventListener('mouseleave',()=>{this.hideTooltip();if(this.isCanvasDragging){this.isCanvasDragging=!1;this.canvas.style.cursor='default';this.dragStartX=null;this.dragStartY=null}
if(this.isAxisDragging){this.isAxisDragging=!1;this.canvas.style.cursor='default';this.dragStartY=null}});this.canvas.addEventListener('wheel',(e)=>{e.preventDefault();if(this.options.showZoom){const rect=this.canvas.getBoundingClientRect();const mouseX=e.clientX-rect.left;if(mouseX>=0&&mouseX<=rect.width){const delta=e.deltaY*-0.006*(this.options.scrollSpeedMultiplier||1.0);const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;const minZoomRange=totalPoints>1?1/(totalPoints-1):0;const currentRange=this.zoomEnd-this.zoomStart;let newRange=currentRange-(delta*currentRange);newRange=Math.max(minZoomRange,Math.min(1,newRange));const center=(this.zoomStart+this.zoomEnd)/2;let newZoomStart=center-(newRange/2);let newZoomEnd=center+(newRange/2);newZoomStart=Math.max(0,Math.min(newZoomStart,1-newRange));newZoomEnd=newZoomStart+newRange;this.zoomStart=newZoomStart;this.zoomEnd=newZoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.calculatePaths();this.redraw();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}}});const observer=new MutationObserver(()=>{this.redraw(!1)});observer.observe(document.documentElement,{attributes:!0,attributeFilter:['class']})}
calculateDynamicPadding(){const{top,right,bottom,left}=this.options.padding;let maxTextWidth=left;let maxTextHeight=bottom;this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;if(this.data.length===0||!this.data[0].points)return{top,right,bottom,left};let allValues=[];let allLabels=[];this.data.forEach(series=>{series.points.forEach(point=>{const value=this.forge.validateNumber(point.y);allValues.push(value);allLabels.push(point.x)})});const minValue=this.options.valueAxisMin!=null?this.options.valueAxisMin:(allValues.length>0?Math.min(...allValues):0);const maxValue=allValues.length>0?Math.max(...allValues):1;const steps=5;for(let i=0;i<=steps;i++){const value=minValue+((maxValue-minValue)/steps)*i;const text=this.forge.formatNumber(value,this.options.useKFormat,this.data[0].valuePrefix,this.data[0].valueAfterfix);const textWidth=this.ctx.measureText(text).width;maxTextWidth=Math.max(maxTextWidth,textWidth+20)}
for(const label of allLabels){const textWidth=this.ctx.measureText(label).width;maxTextHeight=Math.max(maxTextHeight,textWidth+20)}
return{top:this.options.showZoomTool?60:top,right,bottom:maxTextHeight,left:maxTextWidth}}
setData(data,animate=!1){if(this.options.multiSeries){this.data=data.map((series,index)=>{const points=(Array.isArray(series.data)?series.data:(Array.isArray(series.points)?series.points:[])).map(p=>({x:p.name,y:p.value,...p}));if(!points.every(p=>typeof p==='object'&&'x' in p&&'y' in p)){console.warn('Line chart requires data in {name, value} format');return null}
return{...series,name:series.name||`Series ${index + 1}`,color:series.color||this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length],points,valuePrefix:series.valuePrefix||this.options.valuePrefix,valueAfterfix:series.valueAfterfix||this.options.valueAfterfix}}).filter(series=>series!==null)}else{const points=(Array.isArray(data.data)?data.data:(Array.isArray(data.points)?data.points:(Array.isArray(data)?data:[]))).map(p=>({x:p.name,y:p.value,...p}));if(!points.every(p=>typeof p==='object'&&'x' in p&&'y' in p)){console.warn('Line chart requires data in {name, value} format');this.data=[];return}
this.data=[{name:data.name||'Series 1',color:data.color||this.forge.currentDesign.colors[0],points,valuePrefix:data.valuePrefix||this.options.valuePrefix,valueAfterfix:data.valueAfterfix||this.options.valueAfterfix}].filter(series=>series.points.length>0)}
if(this.data.length===0){console.warn('No valid data provided for chart');this.data=[]}
let allY=[];this.data.forEach(series=>{series.points.forEach(point=>{allY.push(this.forge.validateNumber(point.y))})});this.globalMin=allY.length>0?Math.min(...allY):0;this.globalMax=allY.length>0?Math.max(...allY):1;this.hasNegative=this.globalMin<0;const globalRange=this.globalMax-this.globalMin;this.lowestAllowedMin=this.hasNegative?this.globalMin-globalRange*0.1:0;if(this.options.showZoomTool&&this.zoomRange){const primaryColor=this.getPrimaryChartColor();const zoomRangeColor=this.getZoomRangeColor(primaryColor);this.zoomRange.style.background=zoomRangeColor;this.zoomRange.style.boxShadow='inset 0 1px 3px rgba(0,0,0,0.2)'}
const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;if(!this.options.showZoom){this.zoomStart=0;this.zoomEnd=1;this.zoomHandles.left=0;this.zoomHandles.right=1;this.options.zoomRangeStart=0;this.options.zoomRangeEnd=totalPoints}else{this.updateZoomRange(this.options.zoomRangeStart,this.options.zoomRangeEnd,totalPoints)}
let visibleValues=[];this.data.forEach(series=>{series.points.slice(this.options.zoomRangeStart,this.options.zoomRangeEnd+1).forEach(point=>{visibleValues.push(this.forge.validateNumber(point.y))})});if(visibleValues.length>0){const lowPrice=Math.min(...visibleValues);const highPrice=Math.max(...visibleValues);const priceRange=highPrice-lowPrice;const buffer=priceRange*0.1;let minBuffer=lowPrice-buffer;this.options.valueAxisMin=Math.max(this.lowestAllowedMin,minBuffer);this.options.valueAxisMax=highPrice+buffer;this.initialValueAxisMin=this.options.valueAxisMin;this.initialValueAxisMax=this.options.valueAxisMax}else{this.initialValueAxisMin=this.lowestAllowedMin;this.initialValueAxisMax=1}
this.calculatePaths();if(animate&&this.forge.currentDesign.animations){this.animate()}else{this.currentProgress=1;this.draw()}
this.updateLegend()}
calculatePaths(){const rect=this.canvas.getBoundingClientRect();const padding=this.calculateDynamicPadding();const{top,right,bottom,left}=padding;const chartWidth=rect.width-left-right;const chartHeight=rect.height-top-bottom;let allValues=[];this.data.forEach(series=>{series.points.forEach(point=>{allValues.push(this.forge.validateNumber(point.y))})});const minValue=this.options.valueAxisMin!=null?this.options.valueAxisMin:(allValues.length>0?Math.min(...allValues):0);const maxValue=this.options.valueAxisMax!=null?this.options.valueAxisMax:(allValues.length>0?Math.max(...allValues):1);const valueRange=maxValue-minValue||1;this.padding=padding;this.pathCache=this.data.map(series=>{const totalPoints=series.points.length;const startIndex=Math.floor(this.zoomStart*(totalPoints-1));const endIndex=Math.floor(this.zoomEnd*(totalPoints-1));const points=series.points.slice(startIndex,endIndex+1).map((point,index,filteredPoints)=>{const value=this.forge.validateNumber(point.y);const x=left+(index/Math.max(filteredPoints.length-1,1))*chartWidth;let y=top+chartHeight-((value-minValue)/valueRange)*chartHeight;y=Math.max(top,Math.min(y,top+chartHeight));return{x,y,value,originalPoint:point,originalIndex:index+startIndex}});return{...series,points,path:this.createSmoothPath(points)}})}
createSmoothPath(points){if(points.length<2)return'';let path=`M ${points[0].x} ${points[0].y}`;if(this.options.tension===0){for(let i=1;i<points.length;i++){path+=` L ${points[i].x} ${points[i].y}`}}else{const alpha=1-Math.min(Math.max(this.options.tension,0.1),0.9);for(let i=0;i<points.length-1;i++){const p0=i>0?points[i-1]:points[i];const p1=points[i];const p2=points[i+1];const p3=i<points.length-2?points[i+2]:p2;const t1=Math.pow(((p2.x-p0.x)**2+(p2.y-p0.y)**2)**0.5,alpha);const t2=Math.pow(((p3.x-p1.x)**2+(p3.y-p1.y)**2)**0.5,alpha);const cp1x=p1.x+(p2.x-p0.x)/(6*t1);const cp1y=p1.y+(p2.y-p0.y)/(6*t1);const cp2x=p2.x-(p3.x-p1.x)/(6*t2);const cp2y=p2.y-(p3.y-p1.y)/(6*t2);if(i===0){path+=` L ${p1.x} ${p1.y}`}
path+=` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`}}
return path}
animate(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
this.animationProgress=0;this.currentProgress=0;const startTime=Date.now();const duration=this.forge.currentDesign.animationDuration||1000;const animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/duration,1);if(this.animationProgress>=1){this.currentProgress=1}else{this.currentProgress=this.forge.easeInOutCubic(this.animationProgress)}
this.draw();if(this.animationProgress<1){this.animationFrame=requestAnimationFrame(animate)}};animate()}
draw(){if(!this.ctx||!this.canvas)return;const rect=this.canvas.getBoundingClientRect();const{top,right,bottom,left}=this.padding;const chartWidth=rect.width-left-right;const chartHeight=rect.height-top-bottom;this.ctx.clearRect(0,0,rect.width,rect.height);if(this.data.length===0){this.drawEmptyState(rect.width/2,rect.height/2);return}
if(this.options.showGrid){this.drawGrid(left,top,chartWidth,chartHeight)}
this.ctx.save();this.ctx.beginPath();this.ctx.rect(left,top,chartWidth,chartHeight);this.ctx.clip();this.pathCache.forEach((series,seriesIndex)=>{this.drawSeries(series,seriesIndex)});this.ctx.restore();this.drawAxes(left,top,chartWidth,chartHeight);if(this.options.showLabels){this.drawLabels(left,top,chartWidth,chartHeight)}}
drawGrid(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('gridColor');this.ctx.lineWidth=1;this.ctx.setLineDash([2,4]);for(let i=0;i<=5;i++){const gridY=y+(height/5)*i;this.ctx.beginPath();this.ctx.moveTo(x,gridY);this.ctx.lineTo(x+width,gridY);this.ctx.stroke()}
const verticalLines=Math.min(this.pathCache[0]?.points?.length-1||8,8);for(let i=0;i<=verticalLines;i++){const gridX=x+(width/verticalLines)*i;this.ctx.beginPath();this.ctx.moveTo(gridX,y);this.ctx.lineTo(gridX,y+height);this.ctx.stroke()}
this.ctx.setLineDash([])}
drawSeries(series,seriesIndex){if(!series.points||series.points.length===0)return;const totalPoints=series.points.length;const currentPointIndex=Math.floor(this.currentProgress*(totalPoints-1));const pointProgress=(this.currentProgress*(totalPoints-1))%1;this.ctx.strokeStyle=series.color;this.ctx.lineWidth=this.options.lineWidth;this.ctx.lineCap='round';this.ctx.lineJoin='round';const partialPoints=series.points.slice(0,currentPointIndex+1);if(currentPointIndex<series.points.length-1&&pointProgress>0){const current=series.points[currentPointIndex];const next=series.points[currentPointIndex+1];const partialX=current.x+(next.x-current.x)*pointProgress;const partialY=current.y+(next.y-current.y)*pointProgress;partialPoints.push({x:partialX,y:partialY})}
const partialPath=this.createSmoothPath(partialPoints);if(this.forge.currentDesign.glowEffect&&this.forge.currentDesign.animations&&this.currentProgress<1){const tempCanvas=document.createElement('canvas');tempCanvas.width=this.canvas.width;tempCanvas.height=this.canvas.height;const tempCtx=tempCanvas.getContext('2d');tempCtx.strokeStyle=this.ctx.strokeStyle;tempCtx.lineWidth=this.ctx.lineWidth;tempCtx.lineCap=this.ctx.lineCap;tempCtx.lineJoin=this.ctx.lineJoin;tempCtx.shadowColor=series.color;tempCtx.shadowBlur=this.forge.currentDesign.shadowBlur;tempCtx.beginPath();tempCtx.stroke(new Path2D(partialPath));const fraction=this.currentProgress;tempCtx.beginPath();tempCtx.rect(0,0,this.canvas.width*fraction,this.canvas.height);tempCtx.clip();tempCtx.stroke(new Path2D(partialPath));this.ctx.drawImage(tempCanvas,0,0);this.ctx.beginPath();this.ctx.stroke(new Path2D(partialPath))}else if(this.forge.currentDesign.glowEffect){this.ctx.shadowColor=series.color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;const path=new Path2D(this.forge.currentDesign.animations&&this.currentProgress<1?partialPath:series.path);this.ctx.beginPath();this.ctx.stroke(path);this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0}else{const path=new Path2D(this.forge.currentDesign.animations&&this.currentProgress<1?partialPath:series.path);this.ctx.beginPath();this.ctx.stroke(path)}
if(this.options.showPoints){this.drawPoints(series,seriesIndex)}
if(this.options.showValues){this.drawValues(series)}}
drawPoints(series,seriesIndex){series.points.forEach((point,pointIndex)=>{const totalPoints=series.points.length;const progressIndex=this.currentProgress*(totalPoints-1);if(pointIndex>progressIndex)return;const isHovered=this.hoveredPoint.seriesIndex===seriesIndex&&this.hoveredPoint.pointIndex===pointIndex;const radius=isHovered?this.options.pointRadius+2:this.options.pointRadius;this.ctx.fillStyle=this.forge.getDesignValue('background');this.ctx.beginPath();this.ctx.arc(point.x,point.y,radius+1,0,2*Math.PI);this.ctx.fill();this.ctx.fillStyle=series.color;this.ctx.beginPath();this.ctx.arc(point.x,point.y,radius,0,2*Math.PI);this.ctx.fill();this.ctx.strokeStyle=this.forge.getDesignValue('borderColor');this.ctx.lineWidth=1;this.ctx.stroke();if(isHovered){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.stroke()}})}
drawValues(series){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontWeight} ${this.forge.currentDesign.fontSize - 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='bottom';series.points.forEach((point,index)=>{const totalPoints=series.points.length;const progressIndex=this.currentProgress*(totalPoints-1);if(index>progressIndex)return;const value=this.forge.validateNumber(point.value);this.ctx.fillText(this.forge.formatNumber(value,this.options.useKFormat,series.valuePrefix,series.valueAfterfix),point.x,point.y-8)})}
drawAxes(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.beginPath();this.ctx.moveTo(x,y);this.ctx.lineTo(x,y+height);this.ctx.moveTo(x,y+height);this.ctx.lineTo(x+width,y+height);this.ctx.stroke();this.drawValueAxis(x,y,width,height)}
drawValueAxis(x,y,width,height){let allValues=[];this.data.forEach(series=>{if(series.points){series.points.forEach(point=>{allValues.push(this.forge.validateNumber(point.y))})}});if(allValues.length===0){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='right';this.ctx.textBaseline='middle';this.ctx.fillText('N/A',x-10,y+height/2);return}
const minValue=this.options.valueAxisMin!=null?this.options.valueAxisMin:(allValues.length>0?Math.min(...allValues):0);const maxValue=this.options.valueAxisMax!=null?this.options.valueAxisMax:(allValues.length>0?Math.max(...allValues):1);const valueRange=maxValue-minValue||1;const steps=5;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;for(let i=0;i<=steps;i++){const value=minValue+((maxValue-minValue)/steps)*(steps-i);const axisY=y+(height/steps)*i;this.ctx.textAlign='right';this.ctx.textBaseline='middle';const formattedValue=this.forge.formatNumber(value,this.options.useKFormat,this.data[0].valuePrefix,this.data[0].valueAfterfix);this.ctx.fillText(formattedValue,x-10,axisY)}}
drawLabels(x,y,width,height){if(this.data.length===0||!this.data[0].points)return;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='top';const visiblePoints=this.pathCache[0].points;if(visiblePoints.length===0)return;let padding;if(window.innerWidth<=768){padding=70}else{padding=100}
let lastLabelX=x;visiblePoints.forEach((point,index)=>{const labelX=x+(index/Math.max(visiblePoints.length-1,1))*width;const label=point.originalPoint.x;const labelWidth=this.ctx.measureText(label).width;const nextLabelX=labelX+(labelWidth/2);if(nextLabelX-(labelWidth/2)>lastLabelX+padding||index===0){this.ctx.fillText(label,labelX,y+height+15);lastLabelX=nextLabelX}})}
updateLegend(){if(!this.legendContainer)return;this.legendContainer.parentElement.style.display=this.options.showLegend?'block':'none';this.legendContainer.innerHTML=this.data.map(series=>`
            <div style="display: flex; align-items: center; margin-bottom: 8px; font-size: ${this.forge.currentDesign.fontSize}px; font-family: ${this.forge.currentDesign.fontFamily};">
                <div style="width: 16px; height: 3px; background-color: ${series.color}; margin-right: 8px; border-radius: 2px;"></div>
                <span style="color: ${this.forge.getDesignValue('textColor')};">${series.name}</span>
            </div>
        `).join('')}
drawEmptyState(centerX,centerY){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize + 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('No Data Available',centerX,centerY)}
handleMouseMove(e){if(!this.options.showTooltip)return;const isMobile=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent);const rect=this.canvas.getBoundingClientRect();const clientX=e.type.includes('touch')?e.touches[0].clientX:e.clientX;const clientY=e.type.includes('touch')?e.touches[0].clientY:e.clientY;const mouseX=clientX-rect.left;const mouseY=clientY-rect.top;const previousHover={...this.hoveredPoint};this.hoveredPoint={seriesIndex:-1,pointIndex:-1};let closestDistance=Infinity;let closestPoint=null;if(mouseX>=this.padding.left&&mouseX<=rect.width-this.padding.right&&mouseY>=this.padding.top&&mouseY<=rect.height-this.padding.bottom){this.pathCache.forEach((series,seriesIndex)=>{series.points.forEach((point,pointIndex)=>{const distanceToVerticalLine=Math.abs(mouseX-point.x);const distanceToPoint=Math.hypot(mouseX-point.x,mouseY-point.y);const proximityThreshold=this.options.pointRadius+10;if(isMobile){if(distanceToVerticalLine<proximityThreshold&&distanceToPoint<proximityThreshold&&distanceToVerticalLine<closestDistance){closestDistance=distanceToVerticalLine;closestPoint={seriesIndex,pointIndex,point,series}}}else{if((this.options.showAdvancedTooltip||distanceToVerticalLine<this.options.pointRadius+8)&&distanceToVerticalLine<closestDistance){closestDistance=distanceToVerticalLine;closestPoint={seriesIndex,pointIndex,point,series}}}})})}
if(closestPoint){this.hoveredPoint={seriesIndex:closestPoint.seriesIndex,pointIndex:closestPoint.pointIndex};this.showTooltip(e,closestPoint)}else{this.hideTooltip()}
if(previousHover.seriesIndex!==this.hoveredPoint.seriesIndex||previousHover.pointIndex!==this.hoveredPoint.pointIndex){this.draw()}}
showTooltip(e,closestPoint){if(!this.tooltip||!this.options.showTooltip)return;const{point,series}=closestPoint;const formattedValue=this.forge.formatNumber(point.value,this.options.useKFormat,series.valuePrefix,series.valueAfterfix);const label=point.originalPoint.x;this.tooltip.innerHTML=`
            <div>
                <div style="font-weight: 600; margin-bottom: 2px;">${series.name}</div>
                <div>${label}: ${formattedValue}</div>
            </div>
        `;this.tooltip.style.display='block';const offsetX=point.x+10;const offsetY=point.y-10;this.tooltip.style.left=`${offsetX}px`;this.tooltip.style.top=`${offsetY}px`;const tooltipRect=this.tooltip.getBoundingClientRect();const canvasRect=this.canvas.getBoundingClientRect();if(offsetX+tooltipRect.width>canvasRect.width){this.tooltip.style.left=`${offsetX - tooltipRect.width - 10}px`}
if(offsetY-tooltipRect.height<0){this.tooltip.style.top=`${offsetY + 20}px`}}
hideTooltip(){if(this.tooltip){this.tooltip.style.display='none'}}
redraw(animate=!1){this.updateContainerBackground();this.calculatePaths();if(animate&&this.forge.currentDesign.animations){this.animate()}else{this.currentProgress=1;this.draw()}
this.updateLegend();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}
destroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
window.removeEventListener('resize',this.setupCanvas);this.canvas.removeEventListener('mousedown',this.handleMouseDown);this.canvas.removeEventListener('touchstart',this.handleMouseDown);this.canvas.removeEventListener('mousemove',this.handleMouseMove);this.canvas.removeEventListener('touchmove',this.handleMouseMove);this.canvas.removeEventListener('mouseup',this.handleMouseUp);this.canvas.removeEventListener('touchend',this.handleMouseUp);this.canvas.removeEventListener('mouseleave',this.handleMouseLeave);this.canvas.removeEventListener('wheel',this.handleWheel);if(this.leftHandle){this.leftHandle.removeEventListener('mousedown',this.startDrag);this.leftHandle.removeEventListener('touchstart',this.startDrag)}
if(this.rightHandle){this.rightHandle.removeEventListener('mousedown',this.startDrag);this.rightHandle.removeEventListener('touchstart',this.startDrag)}}}
class ChartForgeArea{constructor(containerId,options={},forge){this.container=document.getElementById(containerId);if(!this.container)throw new Error(`Container with ID '${containerId}' not found`);this.forge=forge;this.canvas=null;this.ctx=null;this.data=[];this.options={showGrid:!0,showLabels:!0,showTooltip:!0,showPoints:!0,showValues:!1,lineWidth:2,pointRadius:4,tension:0.4,fillOpacity:0.3,padding:{top:40,right:40,bottom:60,left:60},multiSeries:!1,showLegend:!0,useKFormat:!1,showZoom:!1,showZoomTool:!1,zoomRangeStart:0,zoomRangeEnd:0,scrollSpeedMultiplier:1.0,moveSpeedMultiplier:1.0,valuePrefix:'',valueAfterfix:'',showAdvancedTooltip:!1,pinchZoomSensitivity:0.05,...options};this.tooltip=null;this.animationFrame=null;this.currentProgress=0;this.targetProgress=1;this.animationProgress=0;this.hoveredPoint={seriesIndex:-1,pointIndex:-1};this.pathCache=[];this.chartContainer=null;this.legendContainer=null;this.zoomLevel=1;this.zoomStart=0;this.zoomEnd=1;this.zoomHandles={left:this.zoomStart,right:this.zoomEnd};this.isDragging={left:!1,right:!1,range:!1};this.isCanvasDragging=!1;this.isAxisDragging=!1;this.dragStartX=null;this.dragStartY=null;this.initialValueAxisMin=0;this.initialValueAxisMax=null;this.minHandleOffset=0.01;this.pinchStartDistance=null;this.pinchCenterX=null;this.padding=this.options.padding;this.globalMin=0;this.globalMax=1;this.hasNegative=!1;this.lowestAllowedMin=0;this.init();this.setupEventListeners()}
normalizeZoomIndex(index,totalPoints){if(totalPoints<=1)return index;return Math.max(0,Math.min(1,index/(totalPoints-1)))}
updateZoomRange(startIndex,endIndex,totalPoints){if(totalPoints<=1){this.zoomStart=0;this.zoomEnd=1}else{const normalizedStart=this.normalizeZoomIndex(startIndex,totalPoints);const normalizedEnd=this.normalizeZoomIndex(endIndex,totalPoints);this.zoomStart=Math.max(0+this.minHandleOffset,Math.min(normalizedStart,1-this.minHandleOffset));this.zoomEnd=Math.max(0+this.minHandleOffset,Math.min(normalizedEnd,1-this.minHandleOffset));if(this.zoomStart>this.zoomEnd){[this.zoomStart,this.zoomEnd]=[this.zoomEnd,this.zoomStart]}}
this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.calculatePaths();this.redraw();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}
init(){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';const primaryColor=this.forge.currentDesign.colors[0]||'#14B8A6';const zoomRangeColor=this.getZoomRangeColor(primaryColor);this.container.innerHTML=`
            <div class="chartforge-area-container" style="width: 100%; height: 100%; position: relative; background: ${this.forge.getDesignValue('background')};">
                <canvas style="width: 100%; height: 100%;"></canvas>
                ${this.options.showZoomTool ? `<div class="chartforge-zoom-tool" style="position: absolute; top: 10px; left: 60px; right: 60px; height: 20px; background: ${this.forge.getDesignValue('gridColor')}; border-radius: 10px; overflow: hidden; z-index: 10;"><div class="zoom-range" style="position: absolute; top: 0; bottom: 0; background: ${zoomRangeColor}; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);"></div><div class="zoom-handle left-handle" style="position: absolute; top: 0; bottom: 0; width: 10px; background: ${this.forge.getDesignValue('textColor')}; cursor: ew-resize; z-index: 11;"></div><div class="zoom-handle right-handle" style="position: absolute; top: 0; bottom: 0; width: 10px; background: ${this.forge.getDesignValue('textColor')}; cursor: ew-resize; z-index: 11;"></div></div>` : ''}
                <div class="chartforge-tooltip" style="position: absolute; display: none; background: rgba(17, 24, 39, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></div>
                ${this.options.showLegend ? `<div class="chartforge-legend" style="position: absolute; top: ${this.options.showZoomTool ? '40px' : '20px'}; right: 20px; background: ${legendBackground}; padding: 16px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); max-width: 200px;"><div class="legend-items"></div></div>` : ''}
            </div>
        `;this.chartContainer=this.container.querySelector('.chartforge-area-container');this.canvas=this.container.querySelector('canvas');this.ctx=this.canvas.getContext('2d');this.tooltip=this.container.querySelector('.chartforge-tooltip');this.legendContainer=this.container.querySelector('.legend-items');this.zoomTool=this.container.querySelector('.chartforge-zoom-tool');this.zoomRange=this.container.querySelector('.zoom-range');this.leftHandle=this.container.querySelector('.left-handle');this.rightHandle=this.container.querySelector('.right-handle');this.setupCanvas();this.setupZoom()}
getPrimaryChartColor(){if(this.data&&this.data.length>0&&this.data[0].fillColor){return this.data[0].fillColor}
return this.forge.currentDesign.colors[0]||'#14B8A6'}
getZoomRangeColor(primaryColor){const hex=primaryColor.replace('#','');const r=parseInt(hex.substr(0,2),16);const g=parseInt(hex.substr(2,2),16);const b=parseInt(hex.substr(4,2),16);return `rgba(${r}, ${g}, ${b}, 0.15)`}
updateContainerBackground(){if(this.chartContainer){this.chartContainer.style.background=this.forge.getDesignValue('background')}
const legendElement=this.container.querySelector('.chartforge-legend');if(legendElement){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';legendElement.style.background=legendBackground}}
setupCanvas(){const resizeCanvas=()=>{const rect=this.canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;this.canvas.width=rect.width*dpr;this.canvas.height=rect.height*dpr;this.ctx.scale(dpr,dpr);this.canvas.style.width=rect.width+'px';this.canvas.style.height=rect.height+'px';this.calculatePaths();this.redraw(!1)};resizeCanvas();window.addEventListener('resize',resizeCanvas)}
setupZoom(){if(!this.options.showZoom||!this.zoomTool)return;this.updateZoomHandles();const startDrag=(e,handle)=>{e.preventDefault();this.isDragging[handle]=!0;const rect=this.zoomTool.getBoundingClientRect();const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;const minZoomRange=totalPoints>1?1/(totalPoints-1):0;const moveHandler=(moveEvent)=>{if(!this.isDragging[handle])return;const clientX=moveEvent.type.includes('touch')?moveEvent.touches[0].clientX:moveEvent.clientX;const newX=clientX-rect.left;let percentage=Math.max(0,Math.min(100,(newX/rect.width)*100))/100;if(handle==='left'){percentage=Math.max(this.minHandleOffset,Math.min(percentage,this.zoomHandles.right-minZoomRange));this.zoomHandles.left=percentage}else if(handle==='right'){percentage=Math.min(1-this.minHandleOffset,Math.max(percentage,this.zoomHandles.left+minZoomRange));this.zoomHandles.right=percentage}else if(handle==='range'){const rangeWidth=this.zoomHandles.right-this.zoomHandles.left;const center=percentage;let newLeft=center-rangeWidth/2;let newRight=center+rangeWidth/2;if(newLeft<this.minHandleOffset){newLeft=this.minHandleOffset;newRight=newLeft+rangeWidth}else if(newRight>1-this.minHandleOffset){newRight=1-this.minHandleOffset;newLeft=newRight-rangeWidth}
this.zoomHandles.left=newLeft;this.zoomHandles.right=newRight}
this.zoomStart=this.zoomHandles.left;this.zoomEnd=this.zoomHandles.right;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.calculatePaths();this.redraw();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}};const stopDrag=()=>{this.isDragging[handle]=!1;window.removeEventListener('mousemove',moveHandler);window.removeEventListener('touchmove',moveHandler);window.removeEventListener('mouseup',stopDrag);window.removeEventListener('touchend',stopDrag);if(handle==='range'){this.zoomRange.style.cursor='grab'}};window.addEventListener('mousemove',moveHandler);window.addEventListener('touchmove',moveHandler,{passive:!1});window.addEventListener('mouseup',stopDrag);window.addEventListener('touchend',stopDrag)};this.leftHandle.addEventListener('mousedown',(e)=>startDrag(e,'left'));this.leftHandle.addEventListener('touchstart',(e)=>startDrag(e,'left'),{passive:!1});this.rightHandle.addEventListener('mousedown',(e)=>startDrag(e,'right'));this.rightHandle.addEventListener('touchstart',(e)=>startDrag(e,'right'),{passive:!1});if(this.zoomRange){this.zoomRange.style.cursor='grab';this.zoomRange.addEventListener('mousedown',(e)=>{if(e.target===this.leftHandle||e.target===this.rightHandle)return;this.zoomRange.style.cursor='grabbing';startDrag(e,'range')});this.zoomRange.addEventListener('touchstart',(e)=>{if(e.target===this.leftHandle||e.target===this.rightHandle)return;this.zoomRange.style.cursor='grabbing';startDrag(e,'range')},{passive:!1})}}
updateZoomHandles(){if(!this.zoomTool||!this.options.showZoomTool)return;this.leftHandle.style.left=`${Math.max(this.minHandleOffset * 100, Math.min(100 - this.minHandleOffset * 100, this.zoomHandles.left * 100))}%`;this.rightHandle.style.left=`${Math.max(this.minHandleOffset * 100, Math.min(100 - this.minHandleOffset * 100, this.zoomHandles.right * 100))}%`;this.zoomRange.style.left=`${this.zoomHandles.left * 100}%`;this.zoomRange.style.width=`${(this.zoomHandles.right - this.zoomHandles.left) * 100}%`}
setupEventListeners(){const startCanvasDrag=(e)=>{e.preventDefault();const rect=this.canvas.getBoundingClientRect();const clientX=e.type.includes('touch')?e.touches[0].clientX:e.clientX;const clientY=e.type.includes('touch')?e.touches[0].clientY:e.clientY;const mouseX=clientX-rect.left;const mouseY=clientY-rect.top;const{left}=this.padding;if(mouseX<=left&&mouseY>=this.padding.top&&mouseY<=rect.height-this.padding.bottom){this.isAxisDragging=!0;this.dragStartY=clientY;this.initialValueAxisMin=this.options.valueAxisMin;this.initialValueAxisMax=this.options.valueAxisMax;this.canvas.style.cursor='ns-resize';this.hideTooltip()}else{this.isCanvasDragging=!0;this.dragStartX=clientX;this.dragStartY=clientY;this.canvas.style.cursor='grabbing'}
if(e.type.includes('touch')&&this.options.showTooltip){this.handleMouseMove(e)}};const moveCanvas=(e)=>{e.preventDefault();const clientX=e.type.includes('touch')?e.touches[0].clientX:e.clientX;const clientY=e.type.includes('touch')?e.touches[0].clientY:e.clientY;if(this.isAxisDragging){const rect=this.canvas.getBoundingClientRect();const deltaY=clientY-this.dragStartY;const chartHeight=rect.height-this.padding.top-this.padding.bottom;const sensitivity=1.5;const midPrice=(this.initialValueAxisMin+this.initialValueAxisMax)/2;const initialRange=this.initialValueAxisMax-this.initialValueAxisMin;const scaleFactor=1+(deltaY/chartHeight)*sensitivity;let newRange=initialRange*scaleFactor;let newMin=midPrice-newRange/2;let newMax=midPrice+newRange/2;if(newMin<this.lowestAllowedMin){newMin=this.lowestAllowedMin;newMax=newMin+newRange}
this.options.valueAxisMin=newMin;this.options.valueAxisMax=newMax;this.calculatePaths();this.redraw()}else if(this.isCanvasDragging){const rect=this.canvas.getBoundingClientRect();const deltaX=clientX-this.dragStartX;const deltaY=clientY-this.dragStartY;const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;const chartWidth=rect.width-this.padding.left-this.padding.right;const chartHeight=rect.height-this.padding.top-this.padding.bottom;const range=this.zoomEnd-this.zoomStart;const horizontalShift=(deltaX/chartWidth)*range*this.options.moveSpeedMultiplier;const valueRange=this.options.valueAxisMax-this.options.valueAxisMin;const verticalShift=(deltaY/chartHeight)*valueRange*this.options.moveSpeedMultiplier;let newZoomStart=this.zoomStart-horizontalShift;let newZoomEnd=this.zoomEnd-horizontalShift;newZoomStart=Math.max(0,Math.min(newZoomStart,1-range));newZoomEnd=newZoomStart+range;this.zoomStart=newZoomStart;this.zoomEnd=newZoomEnd;this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.options.valueAxisMin+=verticalShift;this.options.valueAxisMax+=verticalShift;if(this.options.valueAxisMin<this.lowestAllowedMin){const diff=this.lowestAllowedMin-this.options.valueAxisMin;this.options.valueAxisMin+=diff;this.options.valueAxisMax+=diff}
this.dragStartX=clientX;this.dragStartY=clientY;this.calculatePaths();this.redraw();if(this.options.showTooltip&&e.type.includes('touch')){this.handleMouseMove(e)}
if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}else{const rect=this.canvas.getBoundingClientRect();const mouseX=clientX-rect.left;const mouseY=clientY-rect.top;const{left}=this.padding;if(mouseX<=left&&mouseY>=this.padding.top&&mouseY<=rect.height-this.padding.bottom){this.canvas.style.cursor='ns-resize'}else{this.canvas.style.cursor='default'}
if(!/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)){this.handleMouseMove(e)}}};const stopCanvasDrag=()=>{if(this.isAxisDragging){this.isAxisDragging=!1;this.canvas.style.cursor='default';this.dragStartY=null}
if(this.isCanvasDragging){this.isCanvasDragging=!1;this.canvas.style.cursor='default';this.dragStartX=null;this.dragStartY=null;this.hideTooltip()}};const handlePinch=(e)=>{e.preventDefault();if(!this.options.showZoom||e.touches.length!==2)return;const rect=this.canvas.getBoundingClientRect();const touch1={x:e.touches[0].clientX-rect.left,y:e.touches[0].clientY-rect.top};const touch2={x:e.touches[1].clientX-rect.left,y:e.touches[1].clientY-rect.top};if(touch1.x<this.padding.left||touch1.x>rect.width-this.padding.right||touch2.x<this.padding.left||touch2.x>rect.width-this.padding.right)return;const distance=Math.hypot(touch1.x-touch2.x,touch1.y-touch2.y);this.pinchCenterX=(touch1.x+touch2.x)/2;if(this.pinchStartDistance===null){this.pinchStartDistance=distance;return}
const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;const minZoomRange=totalPoints>1?1/(totalPoints-1):0;const currentRange=this.zoomEnd-this.zoomStart;const rawScaleFactor=this.pinchStartDistance/distance;const sensitivity=this.options.pinchZoomSensitivity||0.05;const scaleFactor=1+(rawScaleFactor-1)*sensitivity;let newRange=currentRange*scaleFactor;newRange=Math.max(minZoomRange,Math.min(1,newRange));const normalizedCenter=(this.pinchCenterX-this.padding.left)/(rect.width-this.padding.left-this.padding.right);const center=this.zoomStart+(this.zoomEnd-this.zoomStart)*normalizedCenter;let newZoomStart=center-(newRange/2);let newZoomEnd=center+(newRange/2);newZoomStart=Math.max(0,Math.min(newZoomStart,1-newRange));newZoomEnd=newZoomStart+newRange;this.zoomStart=newZoomStart;this.zoomEnd=newZoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.calculatePaths();this.redraw();this.hideTooltip();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}};this.canvas.addEventListener('mousedown',startCanvasDrag);this.canvas.addEventListener('touchstart',(e)=>{if(e.touches.length===1){startCanvasDrag(e)}else if(e.touches.length===2){this.pinchStartDistance=null;handlePinch(e)}},{passive:!1});this.canvas.addEventListener('mousemove',moveCanvas);this.canvas.addEventListener('touchmove',(e)=>{if(e.touches.length===1){moveCanvas(e)}else if(e.touches.length===2){handlePinch(e)}},{passive:!1});this.canvas.addEventListener('mouseup',stopCanvasDrag);this.canvas.addEventListener('touchend',(e)=>{this.pinchStartDistance=null;stopCanvasDrag()});this.canvas.addEventListener('mouseleave',()=>{this.hideTooltip();if(this.isCanvasDragging){this.isCanvasDragging=!1;this.canvas.style.cursor='default';this.dragStartX=null;this.dragStartY=null}
if(this.isAxisDragging){this.isAxisDragging=!1;this.canvas.style.cursor='default';this.dragStartY=null}});this.canvas.addEventListener('wheel',(e)=>{e.preventDefault();if(this.options.showZoom){const rect=this.canvas.getBoundingClientRect();const mouseX=e.clientX-rect.left;if(mouseX>=0&&mouseX<=rect.width){const delta=e.deltaY*-0.006*(this.options.scrollSpeedMultiplier||1.0);const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;const minZoomRange=totalPoints>1?1/(totalPoints-1):0;const currentRange=this.zoomEnd-this.zoomStart;let newRange=currentRange-(delta*currentRange);newRange=Math.max(minZoomRange,Math.min(1,newRange));const center=(this.zoomStart+this.zoomEnd)/2;let newZoomStart=center-(newRange/2);let newZoomEnd=center+(newRange/2);newZoomStart=Math.max(0,Math.min(newZoomStart,1-newRange));newZoomEnd=newZoomStart+newRange;this.zoomStart=newZoomStart;this.zoomEnd=newZoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.calculatePaths();this.redraw();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}}});const observer=new MutationObserver(()=>{this.redraw(!1)});observer.observe(document.documentElement,{attributes:!0,attributeFilter:['class']})}
calculateDynamicPadding(){const{top,right,bottom,left}=this.options.padding;let maxTextWidth=left;let maxTextHeight=bottom;this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;if(this.data.length===0||!this.data[0].points)return{top,right,bottom,left};let allValues=[];let allLabels=[];this.data.forEach(series=>{series.points.forEach(point=>{const value=this.forge.validateNumber(point.y);allValues.push(value);allLabels.push(point.x)})});const minValue=this.options.valueAxisMin!=null?this.options.valueAxisMin:(allValues.length>0?Math.min(...allValues):0);const maxValue=allValues.length>0?Math.max(...allValues):1;const steps=5;for(let i=0;i<=steps;i++){const value=minValue+((maxValue-minValue)/steps)*i;const text=this.forge.formatNumber(value,this.options.useKFormat,this.data[0].valuePrefix,this.data[0].valueAfterfix);const textWidth=this.ctx.measureText(text).width;maxTextWidth=Math.max(maxTextWidth,textWidth+20)}
for(const label of allLabels){const textWidth=this.ctx.measureText(label).width;maxTextHeight=Math.max(maxTextHeight,textWidth+20)}
return{top:this.options.showZoomTool?60:top,right,bottom:maxTextHeight,left:maxTextWidth}}
setData(data,animate=!1){if(this.options.multiSeries){this.data=data.map((series,index)=>{const points=(Array.isArray(series.data)?series.data:(Array.isArray(series.points)?series.points:[])).map(p=>({x:p.name,y:p.value,...p}));if(!points.every(p=>typeof p==='object'&&'x' in p&&'y' in p)){console.warn('Area chart requires data in {name, value} format');return null}
return{...series,name:series.name||`Series ${index + 1}`,color:series.color||this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length],fillColor:series.fillColor||series.color||this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length],points,valuePrefix:series.valuePrefix||this.options.valuePrefix,valueAfterfix:series.valueAfterfix||this.options.valueAfterfix}}).filter(series=>series!==null)}else{const points=(Array.isArray(data.data)?data.data:(Array.isArray(data.points)?data.points:(Array.isArray(data)?data:[]))).map(p=>({x:p.name,y:p.value,...p}));if(!points.every(p=>typeof p==='object'&&'x' in p&&'y' in p)){console.warn('Area chart requires data in {name, value} format');this.data=[];return}
this.data=[{name:data.name||'Series 1',color:data.color||this.forge.currentDesign.colors[0],fillColor:data.fillColor||data.color||this.forge.currentDesign.colors[0],points,valuePrefix:data.valuePrefix||this.options.valuePrefix,valueAfterfix:data.valueAfterfix||this.options.valueAfterfix}].filter(series=>series.points.length>0)}
if(this.data.length===0){console.warn('No valid data provided for chart');this.data=[]}
let allY=[];this.data.forEach(series=>{series.points.forEach(point=>{allY.push(this.forge.validateNumber(point.y))})});this.globalMin=allY.length>0?Math.min(...allY):0;this.globalMax=allY.length>0?Math.max(...allY):1;this.hasNegative=this.globalMin<0;const globalRange=this.globalMax-this.globalMin;this.lowestAllowedMin=this.hasNegative?this.globalMin-globalRange*0.1:0;if(this.options.showZoomTool&&this.zoomRange){const primaryColor=this.getPrimaryChartColor();const zoomRangeColor=this.getZoomRangeColor(primaryColor);this.zoomRange.style.background=zoomRangeColor;this.zoomRange.style.boxShadow='inset 0 1px 3px rgba(0,0,0,0.2)'}
const totalPoints=this.data.length>0?Math.max(...this.data.map(s=>s.points.length-1)):0;if(!this.options.showZoom){this.zoomStart=0;this.zoomEnd=1;this.zoomHandles.left=0;this.zoomHandles.right=1;this.options.zoomRangeStart=0;this.options.zoomRangeEnd=totalPoints}else{this.updateZoomRange(this.options.zoomRangeStart,this.options.zoomRangeEnd,totalPoints)}
let visibleValues=[];this.data.forEach(series=>{series.points.slice(this.options.zoomRangeStart,this.options.zoomRangeEnd+1).forEach(point=>{visibleValues.push(this.forge.validateNumber(point.y))})});if(visibleValues.length>0){const lowPrice=Math.min(...visibleValues);const highPrice=Math.max(...visibleValues);const priceRange=highPrice-lowPrice;const buffer=priceRange*0.1;let minBuffer=lowPrice-buffer;this.options.valueAxisMin=Math.max(this.lowestAllowedMin,minBuffer);this.options.valueAxisMax=highPrice+buffer;this.initialValueAxisMin=this.options.valueAxisMin;this.initialValueAxisMax=this.options.valueAxisMax}else{this.initialValueAxisMin=this.lowestAllowedMin;this.initialValueAxisMax=1}
this.calculatePaths();if(animate&&this.forge.currentDesign.animations){this.animate()}else{this.currentProgress=1;this.draw()}
this.updateLegend()}
calculatePaths(){const rect=this.canvas.getBoundingClientRect();const padding=this.calculateDynamicPadding();const{top,right,bottom,left}=padding;const chartWidth=rect.width-left-right;const chartHeight=rect.height-top-bottom;let allValues=[];this.data.forEach(series=>{series.points.forEach(point=>{allValues.push(this.forge.validateNumber(point.y))})});const minValue=this.options.valueAxisMin!=null?this.options.valueAxisMin:(allValues.length>0?Math.min(...allValues):0);const maxValue=this.options.valueAxisMax!=null?this.options.valueAxisMax:(allValues.length>0?Math.max(...allValues):1);const valueRange=maxValue-minValue||1;this.baseline=top+chartHeight;this.padding=padding;this.pathCache=this.data.map(series=>{const totalPoints=series.points.length;const startIndex=Math.floor(this.zoomStart*(totalPoints-1));const endIndex=Math.floor(this.zoomEnd*(totalPoints-1));const points=series.points.slice(startIndex,endIndex+1).map((point,index,filteredPoints)=>{const value=this.forge.validateNumber(point.y);const x=left+(index/Math.max(filteredPoints.length-1,1))*chartWidth;let y=top+chartHeight-((value-minValue)/valueRange)*chartHeight;y=Math.max(top,Math.min(y,top+chartHeight));return{x,y,value,originalPoint:point,originalIndex:index+startIndex}});return{...series,points,linePath:this.createSmoothPath(points),areaPath:this.createAreaPath(points)}})}
createSmoothPath(points){if(points.length<2)return'';let path=`M ${points[0].x} ${points[0].y}`;if(this.options.tension===0){for(let i=1;i<points.length;i++){path+=` L ${points[i].x} ${points[i].y}`}}else{const alpha=1-Math.min(Math.max(this.options.tension,0.1),0.9);for(let i=0;i<points.length-1;i++){const p0=i>0?points[i-1]:points[i];const p1=points[i];const p2=points[i+1];const p3=i<points.length-2?points[i+2]:p2;const t1=Math.pow(((p2.x-p0.x)**2+(p2.y-p0.y)**2)**0.5,alpha);const t2=Math.pow(((p3.x-p1.x)**2+(p3.y-p1.y)**2)**0.5,alpha);const cp1x=p1.x+(p2.x-p0.x)/(6*t1);const cp1y=p1.y+(p2.y-p0.y)/(6*t1);const cp2x=p2.x-(p3.x-p1.x)/(6*t2);const cp2y=p2.y-(p3.y-p1.y)/(6*t2);if(i===0){path+=` L ${p1.x} ${p1.y}`}
path+=` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`}}
return path}
createAreaPath(points){if(points.length<2)return'';let areaPath=this.createSmoothPath(points);const lastPoint=points[points.length-1];const firstPoint=points[0];areaPath+=` L ${lastPoint.x} ${this.baseline} L ${firstPoint.x} ${this.baseline} Z`;return areaPath}
animate(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
this.animationProgress=0;this.currentProgress=0;const startTime=Date.now();const duration=this.forge.currentDesign.animationDuration||1000;const animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/duration,1);if(this.animationProgress>=1){this.currentProgress=1}else{this.currentProgress=this.forge.easeInOutCubic(this.animationProgress)}
this.draw();if(this.animationProgress<1){this.animationFrame=requestAnimationFrame(animate)}};animate()}
draw(){if(!this.ctx||!this.canvas)return;const rect=this.canvas.getBoundingClientRect();const{top,right,bottom,left}=this.padding;const chartWidth=rect.width-left-right;const chartHeight=rect.height-top-bottom;this.ctx.clearRect(0,0,rect.width,rect.height);if(this.data.length===0){this.drawEmptyState(rect.width/2,rect.height/2);return}
if(this.options.showGrid){this.drawGrid(left,top,chartWidth,chartHeight)}
this.ctx.save();this.ctx.beginPath();this.ctx.rect(left,top,chartWidth,chartHeight);this.ctx.clip();this.pathCache.forEach((series,seriesIndex)=>{this.drawAreaSeries(series,seriesIndex)});this.ctx.restore();this.drawAxes(left,top,chartWidth,chartHeight);if(this.options.showLabels){this.drawLabels(left,top,chartWidth,chartHeight)}}
drawGrid(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('gridColor');this.ctx.lineWidth=1;this.ctx.setLineDash([2,4]);for(let i=0;i<=5;i++){const gridY=y+(height/5)*i;this.ctx.beginPath();this.ctx.moveTo(x,gridY);this.ctx.lineTo(x+width,gridY);this.ctx.stroke()}
const verticalLines=Math.min(this.pathCache[0]?.points?.length-1||8,8);for(let i=0;i<=verticalLines;i++){const gridX=x+(width/verticalLines)*i;this.ctx.beginPath();this.ctx.moveTo(gridX,y);this.ctx.lineTo(gridX,y+height);this.ctx.stroke()}
this.ctx.setLineDash([])}
drawAreaSeries(series,seriesIndex){if(!series.points||series.points.length===0)return;const totalPoints=series.points.length;const currentPointIndex=Math.floor(this.currentProgress*(totalPoints-1));const pointProgress=(this.currentProgress*(totalPoints-1))%1;this.drawAreaLine(series,seriesIndex,currentPointIndex,pointProgress);if(this.currentProgress>=1){const areaColor=this.hexToRgba(series.fillColor||series.color,this.options.fillOpacity);this.ctx.fillStyle=areaColor;if(this.forge.currentDesign.glowEffect){this.ctx.shadowColor=series.fillColor||series.color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur/2}
const path=new Path2D(series.areaPath);this.ctx.fill(path);this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0}
if(this.options.showPoints){this.drawPoints(series,seriesIndex)}
if(this.options.showValues){this.drawValues(series)}}
drawAreaLine(series,seriesIndex,currentPointIndex,pointProgress){this.ctx.strokeStyle=series.color;this.ctx.lineWidth=this.options.lineWidth;this.ctx.lineCap='round';this.ctx.lineJoin='round';const partialPoints=series.points.slice(0,currentPointIndex+1);if(currentPointIndex<series.points.length-1&&pointProgress>0){const current=series.points[currentPointIndex];const next=series.points[currentPointIndex+1];const partialX=current.x+(next.x-current.x)*pointProgress;const partialY=current.y+(next.y-current.y)*pointProgress;partialPoints.push({x:partialX,y:partialY})}
const partialPath=this.createSmoothPath(partialPoints);if(this.forge.currentDesign.glowEffect&&this.forge.currentDesign.animations&&this.currentProgress<1){const tempCanvas=document.createElement('canvas');tempCanvas.width=this.canvas.width;tempCanvas.height=this.canvas.height;const tempCtx=tempCanvas.getContext('2d');tempCtx.strokeStyle=this.ctx.strokeStyle;tempCtx.lineWidth=this.ctx.lineWidth;tempCtx.lineCap=this.ctx.lineCap;tempCtx.lineJoin=this.ctx.lineJoin;tempCtx.shadowColor=series.color;tempCtx.shadowBlur=this.forge.currentDesign.shadowBlur;tempCtx.beginPath();tempCtx.stroke(new Path2D(partialPath));const fraction=this.currentProgress;tempCtx.beginPath();tempCtx.rect(0,0,this.canvas.width*fraction,this.canvas.height);tempCtx.clip();tempCtx.stroke(new Path2D(partialPath));this.ctx.drawImage(tempCanvas,0,0);this.ctx.beginPath();this.ctx.stroke(new Path2D(partialPath))}else if(this.forge.currentDesign.glowEffect){this.ctx.shadowColor=series.color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;const path=new Path2D(this.forge.currentDesign.animations&&this.currentProgress<1?partialPath:series.linePath);this.ctx.beginPath();this.ctx.stroke(path);this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0}else{const path=new Path2D(this.forge.currentDesign.animations&&this.currentProgress<1?partialPath:series.linePath);this.ctx.beginPath();this.ctx.stroke(path)}}
drawPoints(series,seriesIndex){series.points.forEach((point,pointIndex)=>{const totalPoints=series.points.length;const progressIndex=this.currentProgress*(totalPoints-1);if(pointIndex>progressIndex)return;const isHovered=this.hoveredPoint.seriesIndex===seriesIndex&&this.hoveredPoint.pointIndex===pointIndex;const radius=isHovered?this.options.pointRadius+2:this.options.pointRadius;this.ctx.fillStyle=this.forge.getDesignValue('background');this.ctx.beginPath();this.ctx.arc(point.x,point.y,radius+1,0,2*Math.PI);this.ctx.fill();this.ctx.fillStyle=series.color;this.ctx.beginPath();this.ctx.arc(point.x,point.y,radius,0,2*Math.PI);this.ctx.fill();this.ctx.strokeStyle=this.forge.getDesignValue('borderColor');this.ctx.lineWidth=1;this.ctx.stroke();if(isHovered){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.stroke()}})}
drawValues(series){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontWeight} ${this.forge.currentDesign.fontSize - 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='bottom';series.points.forEach((point,index)=>{const totalPoints=series.points.length;const progressIndex=this.currentProgress*(totalPoints-1);if(index>progressIndex)return;const value=this.forge.validateNumber(point.value);this.ctx.fillText(this.forge.formatNumber(value,this.options.useKFormat,series.valuePrefix,series.valueAfterfix),point.x,point.y-8)})}
drawAxes(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.beginPath();this.ctx.moveTo(x,y);this.ctx.lineTo(x,y+height);this.ctx.moveTo(x,y+height);this.ctx.lineTo(x+width,y+height);this.ctx.stroke();this.drawValueAxis(x,y,width,height)}
drawValueAxis(x,y,width,height){let allValues=[];this.data.forEach(series=>{if(series.points){series.points.forEach(point=>{allValues.push(this.forge.validateNumber(point.y))})}});if(allValues.length===0){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='right';this.ctx.textBaseline='middle';this.ctx.fillText('N/A',x-10,y+height/2);return}
const minValue=this.options.valueAxisMin!=null?this.options.valueAxisMin:(allValues.length>0?Math.min(...allValues):0);const maxValue=this.options.valueAxisMax!=null?this.options.valueAxisMax:(allValues.length>0?Math.max(...allValues):1);const valueRange=maxValue-minValue||1;const steps=5;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;for(let i=0;i<=steps;i++){const value=minValue+((maxValue-minValue)/steps)*(steps-i);const axisY=y+(height/steps)*i;this.ctx.textAlign='right';this.ctx.textBaseline='middle';const formattedValue=this.forge.formatNumber(value,this.options.useKFormat,this.data[0].valuePrefix,this.data[0].valueAfterfix);this.ctx.fillText(formattedValue,x-10,axisY)}}
drawLabels(x,y,width,height){if(this.data.length===0||!this.data[0].points)return;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='top';const visiblePoints=this.pathCache[0].points;if(visiblePoints.length===0)return;let padding;if(window.innerWidth<=768){padding=70}else{padding=100}
let lastLabelX=x;visiblePoints.forEach((point,index)=>{const labelX=x+(index/Math.max(visiblePoints.length-1,1))*width;const label=point.originalPoint.x;const labelWidth=this.ctx.measureText(label).width;const nextLabelX=labelX+(labelWidth/2);if(nextLabelX-(labelWidth/2)>lastLabelX+padding||index===0){this.ctx.fillText(label,labelX,y+height+15);lastLabelX=nextLabelX}})}
updateLegend(){if(!this.legendContainer)return;this.legendContainer.parentElement.style.display=this.options.showLegend?'block':'none';this.legendContainer.innerHTML=this.data.map(series=>`
            <div style="display: flex; align-items: center; margin-bottom: 8px; font-size: ${this.forge.currentDesign.fontSize}px; font-family: ${this.forge.currentDesign.fontFamily};">
                <div style="width: 16px; height: 10px; background-color: ${this.hexToRgba(series.fillColor || series.color, this.options.fillOpacity)}; border: 2px solid ${series.color}; margin-right: 8px; border-radius: 2px;"></div>
                <span style="color: ${this.forge.getDesignValue('textColor')};">${series.name}</span>
            </div>
        `).join('')}
hexToRgba(hex,alpha){if(!hex||!hex.startsWith('#'))return `rgba(0, 0, 0, ${alpha})`;const r=parseInt(hex.slice(1,3),16);const g=parseInt(hex.slice(3,5),16);const b=parseInt(hex.slice(5,7),16);return `rgba(${r}, ${g}, ${b}, ${alpha})`}
drawEmptyState(centerX,centerY){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize + 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('No Data Available',centerX,centerY)}
handleMouseMove(e){if(!this.options.showTooltip)return;const isMobile=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent);const rect=this.canvas.getBoundingClientRect();const clientX=e.type.includes('touch')?e.touches[0].clientX:e.clientX;const clientY=e.type.includes('touch')?e.touches[0].clientY:e.clientY;const mouseX=clientX-rect.left;const mouseY=clientY-rect.top;const previousHover={...this.hoveredPoint};this.hoveredPoint={seriesIndex:-1,pointIndex:-1};let closestDistance=Infinity;let closestPoint=null;if(mouseX>=this.padding.left&&mouseX<=rect.width-this.padding.right&&mouseY>=this.padding.top&&mouseY<=rect.height-this.padding.bottom){this.pathCache.forEach((series,seriesIndex)=>{series.points.forEach((point,pointIndex)=>{const distanceToVerticalLine=Math.abs(mouseX-point.x);const distanceToPoint=Math.hypot(mouseX-point.x,mouseY-point.y);const proximityThreshold=this.options.pointRadius+10;if(isMobile){if(distanceToVerticalLine<proximityThreshold&&distanceToPoint<proximityThreshold&&distanceToVerticalLine<closestDistance){closestDistance=distanceToVerticalLine;closestPoint={seriesIndex,pointIndex,point,series}}}else{if((this.options.showAdvancedTooltip||distanceToVerticalLine<this.options.pointRadius+8)&&distanceToVerticalLine<closestDistance){closestDistance=distanceToVerticalLine;closestPoint={seriesIndex,pointIndex,point,series}}}})})}
if(closestPoint){this.hoveredPoint={seriesIndex:closestPoint.seriesIndex,pointIndex:closestPoint.pointIndex};this.showTooltip(e,closestPoint)}else{this.hideTooltip()}
if(previousHover.seriesIndex!==this.hoveredPoint.seriesIndex||previousHover.pointIndex!==this.hoveredPoint.pointIndex){this.draw()}}
showTooltip(e,closestPoint){if(!this.tooltip||!this.options.showTooltip)return;const{point,series}=closestPoint;const formattedValue=this.forge.formatNumber(point.value,this.options.useKFormat,series.valuePrefix,series.valueAfterfix);const label=point.originalPoint.x;this.tooltip.innerHTML=`
            <div>
                <div style="font-weight: 600; margin-bottom: 2px;">${series.name}</div>
                <div>${label}: ${formattedValue}</div>
            </div>
        `;this.tooltip.style.display='block';const offsetX=point.x+10;const offsetY=point.y-10;this.tooltip.style.left=`${offsetX}px`;this.tooltip.style.top=`${offsetY}px`;const tooltipRect=this.tooltip.getBoundingClientRect();const canvasRect=this.canvas.getBoundingClientRect();if(offsetX+tooltipRect.width>canvasRect.width){this.tooltip.style.left=`${offsetX - tooltipRect.width - 10}px`}
if(offsetY-tooltipRect.height<0){this.tooltip.style.top=`${offsetY + 20}px`}}
hideTooltip(){if(this.tooltip){this.tooltip.style.display='none'}}
redraw(animate=!1){this.updateContainerBackground();this.calculatePaths();if(animate&&this.forge.currentDesign.animations){this.animate()}else{this.currentProgress=1;this.draw()}
this.updateLegend();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}
destroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
window.removeEventListener('resize',this.setupCanvas);this.canvas.removeEventListener('mousedown',this.handleMouseDown);this.canvas.removeEventListener('touchstart',this.handleMouseDown);this.canvas.removeEventListener('mousemove',this.handleMouseMove);this.canvas.removeEventListener('touchmove',this.handleMouseMove);this.canvas.removeEventListener('mouseup',this.handleMouseUp);this.canvas.removeEventListener('touchend',this.handleMouseUp);this.canvas.removeEventListener('mouseleave',this.handleMouseLeave);this.canvas.removeEventListener('wheel',this.handleWheel);if(this.leftHandle){this.leftHandle.removeEventListener('mousedown',this.startDrag);this.leftHandle.removeEventListener('touchstart',this.startDrag)}
if(this.rightHandle){this.rightHandle.removeEventListener('mousedown',this.startDrag);this.rightHandle.removeEventListener('touchstart',this.startDrag)}}}
class ChartForgeCandlestick{constructor(containerId,options={},forge){this.container=document.getElementById(containerId);if(!this.container)throw new Error(`Container with ID '${containerId}' not found`);this.forge=forge;this.canvas=null;this.ctx=null;this.data=[];this.options={showGrid:!0,showLabels:!0,showTooltip:!0,showVolume:!1,candleWidth:0.8,wickWidth:1,padding:{top:40,right:40,bottom:60,left:60},colors:{bullish:'#10B981',bearish:'#EF4444',wick:'#6B7280'},volumeHeight:0.25,useKFormat:!1,showZoom:!1,showZoomTool:!1,zoomRangeStart:0,zoomRangeEnd:0,scrollSpeedMultiplier:1.0,moveSpeedMultiplier:1.0,openPrefix:'',openAfterfix:'',openNamePrefix:'',openNameAfterfix:'',highPrefix:'',highAfterfix:'',highNamePrefix:'',highNameAfterfix:'',lowPrefix:'',lowAfterfix:'',lowNamePrefix:'',lowNameAfterfix:'',closePrefix:'',closeAfterfix:'',closeNamePrefix:'',closeNameAfterfix:'',volumePrefix:'',volumeAfterfix:'',volumeNamePrefix:'',volumeNameAfterfix:'',animations:!0,animationDuration:1200,glowEffect:!1,showAdvancedTooltip:!1,pinchZoomSensitivity:0.05,...options};this.tooltip=null;this.animationFrame=null;this.currentProgress=0;this.animationProgress=0;this.hoveredCandle=-1;this.priceRange={min:0,max:0};this.volumeRange={min:0,max:0};this.chartContainer=null;this.zoomLevel=1;this.zoomStart=0;this.zoomEnd=1;this.zoomHandles={left:this.zoomStart,right:this.zoomEnd};this.isDragging={left:!1,right:!1,range:!1};this.isCanvasDragging=!1;this.isAxisDragging=!1;this.dragStartX=null;this.dragStartY=null;this.initialValueAxisMin=null;this.initialValueAxisMax=null;this.minHandleOffset=0.01;this.pinchStartDistance=null;this.pinchCenterX=null;this.padding=this.options.padding;this.globalMin=0;this.globalMax=1;this.hasNegative=!1;this.lowestAllowedMin=0;this.init();this.setupEventListeners()}
normalizeZoomIndex(index,totalPoints){if(totalPoints<=1)return index;return Math.max(0,Math.min(1,index/(totalPoints-1)))}
updateZoomRange(startIndex,endIndex,totalPoints){if(totalPoints<=1){this.zoomStart=0;this.zoomEnd=1}else{const normalizedStart=this.normalizeZoomIndex(startIndex,totalPoints);const normalizedEnd=this.normalizeZoomIndex(endIndex,totalPoints);this.zoomStart=Math.max(0+this.minHandleOffset,Math.min(normalizedStart,1-this.minHandleOffset));this.zoomEnd=Math.max(0+this.minHandleOffset,Math.min(normalizedEnd,1-this.minHandleOffset));if(this.zoomStart>this.zoomEnd){[this.zoomStart,this.zoomEnd]=[this.zoomEnd,this.zoomStart]}}
this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.calculateRanges();this.redraw();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}
updateZoomHandles(){if(!this.zoomTool||!this.options.showZoomTool)return;this.leftHandle.style.left=`${Math.max(this.minHandleOffset * 100, Math.min(100 - this.minHandleOffset * 100, this.zoomHandles.left * 100))}%`;this.rightHandle.style.left=`${Math.max(this.minHandleOffset * 100, Math.min(100 - this.minHandleOffset * 100, this.zoomHandles.right * 100))}%`;this.zoomRange.style.left=`${this.zoomHandles.left * 100}%`;this.zoomRange.style.width=`${(this.zoomHandles.right - this.zoomHandles.left) * 100}%`}
init(){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';const primaryColor=this.options.colors.bullish||'#10B981';const zoomRangeColor=this.getZoomRangeColor(primaryColor);this.container.innerHTML=`
            <div class="chartforge-candlestick-container" style="width: 100%; height: 100%; position: relative; background: ${this.forge.getDesignValue('background')};">
                <canvas style="width: 100%; height: 100%;"></canvas>
                ${this.options.showZoomTool ? `<div class="chartforge-zoom-tool" style="position: absolute; top: 10px; left: 60px; right: 60px; height: 20px; background: ${this.forge.getDesignValue('gridColor')}; border-radius: 10px; overflow: hidden; z-index: 10;"><div class="zoom-range" style="position: absolute; top: 0; bottom: 0; background: ${zoomRangeColor}; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);"></div><div class="zoom-handle left-handle" style="position: absolute; top: 0; bottom: 0; width: 10px; background: ${this.forge.getDesignValue('textColor')}; cursor: ew-resize; z-index: 11;"></div><div class="zoom-handle right-handle" style="position: absolute; top: 0; bottom: 0; width: 10px; background: ${this.forge.getDesignValue('textColor')}; cursor: ew-resize; z-index: 11;"></div></div>` : ''}
                <div class="chartforge-tooltip" style="position: absolute; display: none; background: rgba(17, 24, 39, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 120px;"></div>
            </div>
        `;this.chartContainer=this.container.querySelector('.chartforge-candlestick-container');this.canvas=this.container.querySelector('canvas');this.ctx=this.canvas.getContext('2d');this.tooltip=this.container.querySelector('.chartforge-tooltip');this.zoomTool=this.container.querySelector('.chartforge-zoom-tool');this.zoomRange=this.container.querySelector('.zoom-range');this.leftHandle=this.container.querySelector('.left-handle');this.rightHandle=this.container.querySelector('.right-handle');this.setupCanvas();this.setupZoom()}
getZoomRangeColor(primaryColor){const hex=primaryColor.replace('#','');const r=parseInt(hex.substr(0,2),16);const g=parseInt(hex.substr(2,2),16);const b=parseInt(hex.substr(4,2),16);return `rgba(${r}, ${g}, ${b}, 0.15)`}
updateContainerBackground(){if(this.chartContainer){this.chartContainer.style.background=this.forge.getDesignValue('background')}}
setupCanvas(){const resizeCanvas=()=>{const rect=this.canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;this.canvas.width=rect.width*dpr;this.canvas.height=rect.height*dpr;this.ctx.scale(dpr,dpr);this.canvas.style.width=rect.width+'px';this.canvas.style.height=rect.height+'px';this.calculateRanges();this.redraw(!1)};resizeCanvas();window.addEventListener('resize',resizeCanvas)}
setupZoom(){if(!this.options.showZoom||!this.zoomTool)return;this.updateZoomHandles();const startDrag=(e,handle)=>{e.preventDefault();this.isDragging[handle]=!0;const rect=this.zoomTool.getBoundingClientRect();const totalPoints=this.data.length>0?this.data.length-1:0;const minZoomRange=totalPoints>1?1/(totalPoints-1):0;const moveHandler=(moveEvent)=>{if(!this.isDragging[handle])return;const clientX=moveEvent.type.includes('touch')?moveEvent.touches[0].clientX:moveEvent.clientX;const newX=clientX-rect.left;let percentage=Math.max(0,Math.min(100,(newX/rect.width)*100))/100;if(handle==='left'){percentage=Math.max(this.minHandleOffset,Math.min(percentage,this.zoomHandles.right-minZoomRange));this.zoomHandles.left=percentage}else if(handle==='right'){percentage=Math.min(1-this.minHandleOffset,Math.max(percentage,this.zoomHandles.left+minZoomRange));this.zoomHandles.right=percentage}else if(handle==='range'){const rangeWidth=this.zoomHandles.right-this.zoomHandles.left;const center=percentage;let newLeft=center-rangeWidth/2;let newRight=center+rangeWidth/2;if(newLeft<this.minHandleOffset){newLeft=this.minHandleOffset;newRight=newLeft+rangeWidth}else if(newRight>1-this.minHandleOffset){newRight=1-this.minHandleOffset;newLeft=newRight-rangeWidth}
this.zoomHandles.left=newLeft;this.zoomHandles.right=newRight}
this.zoomStart=this.zoomHandles.left;this.zoomEnd=this.zoomHandles.right;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.calculateRanges();this.redraw();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}};const stopDrag=()=>{this.isDragging[handle]=!1;window.removeEventListener('mousemove',moveHandler);window.removeEventListener('touchmove',moveHandler);window.removeEventListener('mouseup',stopDrag);window.removeEventListener('touchend',stopDrag);if(handle==='range'){this.zoomRange.style.cursor='grab'}};window.addEventListener('mousemove',moveHandler);window.addEventListener('touchmove',moveHandler,{passive:!1});window.addEventListener('mouseup',stopDrag);window.addEventListener('touchend',stopDrag)};this.leftHandle.addEventListener('mousedown',(e)=>startDrag(e,'left'));this.leftHandle.addEventListener('touchstart',(e)=>startDrag(e,'left'),{passive:!1});this.rightHandle.addEventListener('mousedown',(e)=>startDrag(e,'right'));this.rightHandle.addEventListener('touchstart',(e)=>startDrag(e,'right'),{passive:!1});if(this.zoomRange){this.zoomRange.style.cursor='grab';this.zoomRange.addEventListener('mousedown',(e)=>{if(e.target===this.leftHandle||e.target===this.rightHandle)return;this.zoomRange.style.cursor='grabbing';startDrag(e,'range')});this.zoomRange.addEventListener('touchstart',(e)=>{if(e.target===this.leftHandle||e.target===this.rightHandle)return;this.zoomRange.style.cursor='grabbing';startDrag(e,'range')},{passive:!1})}}
updateZoomHandles(){if(!this.zoomTool||!this.options.showZoomTool)return;this.leftHandle.style.left=`${Math.max(this.minHandleOffset * 100, Math.min(100 - this.minHandleOffset * 100, this.zoomHandles.left * 100))}%`;this.rightHandle.style.left=`${Math.max(this.minHandleOffset * 100, Math.min(100 - this.minHandleOffset * 100, this.zoomHandles.right * 100))}%`;this.zoomRange.style.left=`${this.zoomHandles.left * 100}%`;this.zoomRange.style.width=`${(this.zoomHandles.right - this.zoomHandles.left) * 100}%`}
setupEventListeners(){const startCanvasDrag=(e)=>{e.preventDefault();const rect=this.canvas.getBoundingClientRect();const clientX=e.type.includes('touch')?e.touches[0].clientX:e.clientX;const clientY=e.type.includes('touch')?e.touches[0].clientY:e.clientY;const mouseX=clientX-rect.left;const mouseY=clientY-rect.top;const{left}=this.padding;if(mouseX<=left&&mouseY>=this.padding.top&&mouseY<=rect.height-this.padding.bottom){this.isAxisDragging=!0;this.dragStartY=clientY;this.initialValueAxisMin=this.options.valueAxisMin;this.initialValueAxisMax=this.options.valueAxisMax;this.canvas.style.cursor='ns-resize';this.hideTooltip()}else{this.isCanvasDragging=!0;this.dragStartX=clientX;this.dragStartY=clientY;this.canvas.style.cursor='grabbing'}
if(e.type.includes('touch')&&this.options.showTooltip){this.handleMouseMove(e)}};const moveCanvas=(e)=>{e.preventDefault();const clientX=e.type.includes('touch')?e.touches[0].clientX:e.clientX;const clientY=e.type.includes('touch')?e.touches[0].clientY:e.clientY;if(this.isAxisDragging){const rect=this.canvas.getBoundingClientRect();const deltaY=clientY-this.dragStartY;const chartHeight=rect.height-this.padding.top-this.padding.bottom;const sensitivity=1.5;const midPrice=(this.initialValueAxisMin+this.initialValueAxisMax)/2;const initialRange=this.initialValueAxisMax-this.initialValueAxisMin;const scaleFactor=1+(deltaY/chartHeight)*sensitivity;let newRange=initialRange*scaleFactor;let newMin=midPrice-newRange/2;let newMax=midPrice+newRange/2;if(newMin<this.lowestAllowedMin){newMin=this.lowestAllowedMin;newMax=newMin+newRange}
this.options.valueAxisMin=newMin;this.options.valueAxisMax=newMax;this.calculateRanges();this.redraw()}else if(this.isCanvasDragging){const rect=this.canvas.getBoundingClientRect();const deltaX=clientX-this.dragStartX;const deltaY=clientY-this.dragStartY;const totalPoints=this.data.length>0?this.data.length-1:0;const chartWidth=rect.width-this.padding.left-this.padding.right;const chartHeight=rect.height-this.padding.top-this.padding.bottom;const range=this.zoomEnd-this.zoomStart;const horizontalShift=(deltaX/chartWidth)*range*this.options.moveSpeedMultiplier;const valueRange=this.options.valueAxisMax-this.options.valueAxisMin;const verticalShift=(deltaY/chartHeight)*valueRange*this.options.moveSpeedMultiplier;let newZoomStart=this.zoomStart-horizontalShift;let newZoomEnd=this.zoomEnd-horizontalShift;newZoomStart=Math.max(0,Math.min(newZoomStart,1-range));newZoomEnd=newZoomStart+range;this.zoomStart=newZoomStart;this.zoomEnd=newZoomEnd;this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.options.valueAxisMin+=verticalShift;this.options.valueAxisMax+=verticalShift;if(this.options.valueAxisMin<this.lowestAllowedMin){const diff=this.lowestAllowedMin-this.options.valueAxisMin;this.options.valueAxisMin+=diff;this.options.valueAxisMax+=diff}
this.dragStartX=clientX;this.dragStartY=clientY;this.calculateRanges();this.redraw();if(this.options.showTooltip&&e.type.includes('touch')){this.handleMouseMove(e)}
if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}else{const rect=this.canvas.getBoundingClientRect();const mouseX=clientX-rect.left;const mouseY=clientY-rect.top;const{left}=this.padding;if(mouseX<=left&&mouseY>=this.padding.top&&mouseY<=rect.height-this.padding.bottom){this.canvas.style.cursor='ns-resize'}else{this.canvas.style.cursor='default'}
if(!/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)){this.handleMouseMove(e)}}};const stopCanvasDrag=()=>{if(this.isAxisDragging){this.isAxisDragging=!1;this.canvas.style.cursor='default';this.dragStartY=null}
if(this.isCanvasDragging){this.isCanvasDragging=!1;this.canvas.style.cursor='default';this.dragStartX=null;this.dragStartY=null;this.hideTooltip()}};const handlePinch=(e)=>{e.preventDefault();if(!this.options.showZoom||e.touches.length!==2)return;const rect=this.canvas.getBoundingClientRect();const touch1={x:e.touches[0].clientX-rect.left,y:e.touches[0].clientY-rect.top};const touch2={x:e.touches[1].clientX-rect.left,y:e.touches[1].clientY-rect.top};if(touch1.x<this.padding.left||touch1.x>rect.width-this.padding.right||touch2.x<this.padding.left||touch2.x>rect.width-this.padding.right)return;const distance=Math.hypot(touch1.x-touch2.x,touch1.y-touch2.y);this.pinchCenterX=(touch1.x+touch2.x)/2;if(this.pinchStartDistance===null){this.pinchStartDistance=distance;return}
const totalPoints=this.data.length>0?this.data.length-1:0;const minZoomRange=totalPoints>1?1/(totalPoints-1):0;const currentRange=this.zoomEnd-this.zoomStart;const rawScaleFactor=this.pinchStartDistance/distance;const sensitivity=this.options.pinchZoomSensitivity||0.05;const scaleFactor=1+(rawScaleFactor-1)*sensitivity;let newRange=currentRange*scaleFactor;newRange=Math.max(minZoomRange,Math.min(1,newRange));const normalizedCenter=(this.pinchCenterX-this.padding.left)/(rect.width-this.padding.left-this.padding.right);const center=this.zoomStart+(this.zoomEnd-this.zoomStart)*normalizedCenter;let newZoomStart=center-(newRange/2);let newZoomEnd=center+(newRange/2);newZoomStart=Math.max(0,Math.min(newZoomStart,1-newRange));newZoomEnd=newZoomStart+newRange;this.zoomStart=newZoomStart;this.zoomEnd=newZoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.calculateRanges();this.redraw();this.hideTooltip();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}};this.canvas.addEventListener('mousedown',startCanvasDrag);this.canvas.addEventListener('touchstart',(e)=>{if(e.touches.length===1){startCanvasDrag(e)}else if(e.touches.length===2){this.pinchStartDistance=null;handlePinch(e)}},{passive:!1});this.canvas.addEventListener('mousemove',moveCanvas);this.canvas.addEventListener('touchmove',(e)=>{if(e.touches.length===1){moveCanvas(e)}else if(e.touches.length===2){handlePinch(e)}},{passive:!1});this.canvas.addEventListener('mouseup',stopCanvasDrag);this.canvas.addEventListener('touchend',(e)=>{this.pinchStartDistance=null;stopCanvasDrag()});this.canvas.addEventListener('mouseleave',()=>{this.hideTooltip();if(this.isCanvasDragging){this.isCanvasDragging=!1;this.canvas.style.cursor='default';this.dragStartX=null;this.dragStartY=null}
if(this.isAxisDragging){this.isAxisDragging=!1;this.canvas.style.cursor='default';this.dragStartY=null}});this.canvas.addEventListener('wheel',(e)=>{e.preventDefault();if(this.options.showZoom){const rect=this.canvas.getBoundingClientRect();const mouseX=e.clientX-rect.left;if(mouseX>=0&&mouseX<=rect.width){const delta=e.deltaY*-0.006*(this.options.scrollSpeedMultiplier||1.0);const totalPoints=this.data.length>0?this.data.length-1:0;const minZoomRange=totalPoints>1?1/(totalPoints-1):0;const currentRange=this.zoomEnd-this.zoomStart;let newRange=currentRange-(delta*currentRange);newRange=Math.max(minZoomRange,Math.min(1,newRange));const center=(this.zoomStart+this.zoomEnd)/2;let newZoomStart=center-(newRange/2);let newZoomEnd=center+(newRange/2);newZoomStart=Math.max(0,Math.min(newZoomStart,1-newRange));newZoomEnd=newZoomStart+newRange;this.zoomStart=newZoomStart;this.zoomEnd=newZoomEnd;this.options.zoomRangeStart=Math.floor(this.zoomStart*totalPoints);this.options.zoomRangeEnd=Math.floor(this.zoomEnd*totalPoints);this.zoomHandles.left=this.zoomStart;this.zoomHandles.right=this.zoomEnd;this.calculateRanges();this.redraw();if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}}});const observer=new MutationObserver(()=>{this.redraw(!1)});observer.observe(document.documentElement,{attributes:!0,attributeFilter:['class']})}
calculateDynamicPadding(){const{top,right,bottom,left}=this.options.padding;let maxTextWidth=left;let maxTextHeight=bottom;this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;if(this.data.length===0)return{top,right,bottom,left};let allPrices=[];let allLabels=[];this.data.forEach(candle=>{allPrices.push(candle.open,candle.high,candle.low,candle.close);allLabels.push(this.formatDate(candle.date))});const minValue=allPrices.length>0?Math.min(...allPrices):0;const maxValue=allPrices.length>0?Math.max(...allPrices):1;const steps=5;for(let i=0;i<=steps;i++){const value=minValue+((maxValue-minValue)/steps)*i;const text=this.forge.formatNumber(value,this.options.useKFormat,this.options.closePrefix,this.options.closeAfterfix);const textWidth=this.ctx.measureText(text).width;maxTextWidth=Math.max(maxTextWidth,textWidth+20)}
for(const label of allLabels){const textWidth=this.ctx.measureText(label).width;maxTextHeight=Math.max(maxTextHeight,textWidth+20)}
return{top:this.options.showZoomTool?60:top,right,bottom:maxTextHeight,left:maxTextWidth}}
setData(data,animate=!1){this.data=data.map((item,index)=>({...item,index,isBullish:item.close>=item.open}));let allPrices=[];this.data.forEach(candle=>{allPrices.push(candle.open,candle.high,candle.low,candle.close)});this.globalMin=allPrices.length>0?Math.min(...allPrices):0;this.globalMax=allPrices.length>0?Math.max(...allPrices):1;this.hasNegative=this.globalMin<0;const globalRange=this.globalMax-this.globalMin;this.lowestAllowedMin=this.hasNegative?this.globalMin-globalRange*0.1:0;if(this.options.showZoomTool&&this.zoomRange){const primaryColor=this.options.colors.bullish||'#10B981';const zoomRangeColor=this.getZoomRangeColor(primaryColor);this.zoomRange.style.background=zoomRangeColor;this.zoomRange.style.boxShadow='inset 0 1px 3px rgba(0,0,0,0.2)'}
const totalPoints=this.data.length>0?this.data.length-1:0;if(!this.options.showZoom){this.zoomStart=0;this.zoomEnd=1;this.zoomHandles.left=0;this.zoomHandles.right=1;this.options.zoomRangeStart=0;this.options.zoomRangeEnd=totalPoints}else{this.updateZoomRange(this.options.zoomRangeStart,this.options.zoomRangeEnd,totalPoints)}
const lowPrice=this.globalMin;const highPrice=this.globalMax;const priceRange=highPrice-lowPrice;const buffer=priceRange*0.1;let minBuffer=lowPrice-buffer;this.options.valueAxisMin=Math.max(this.lowestAllowedMin,minBuffer);this.options.valueAxisMax=highPrice+buffer;this.initialValueAxisMin=this.options.valueAxisMin;this.initialValueAxisMax=this.options.valueAxisMax;this.calculateRanges();if(animate&&this.options.animations){this.animate()}else{this.currentProgress=1;this.draw()}}
calculateRanges(){if(this.data.length===0)return;this.priceRange={min:this.options.valueAxisMin,max:this.options.valueAxisMax};if(this.priceRange.max<=this.priceRange.min){this.priceRange.max=this.priceRange.min+1}
if(this.options.showVolume&&this.data.some(d=>d.volume!==undefined)){const volumes=this.getVisibleCandles().map(d=>d.volume||0);this.volumeRange={min:0,max:Math.max(...volumes,1)}}}
animate(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
this.animationProgress=0;this.currentProgress=0;const startTime=Date.now();const duration=this.options.animationDuration||1200;const animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/duration,1);if(this.animationProgress>=1){this.currentProgress=1}else{this.currentProgress=this.forge.easeInOutCubic(this.animationProgress)}
this.draw();if(this.animationProgress<1){this.animationFrame=requestAnimationFrame(animate)}};animate()}
draw(){const rect=this.canvas.getBoundingClientRect();this.padding=this.calculateDynamicPadding();const{top,right,bottom,left}=this.padding;const totalChartHeight=rect.height-top-bottom;const volumeHeight=this.options.showVolume?totalChartHeight*this.options.volumeHeight:0;const priceHeight=totalChartHeight-volumeHeight;const chartWidth=rect.width-left-right;this.priceArea={x:left,y:top,width:chartWidth,height:priceHeight};this.volumeArea=this.options.showVolume?{x:left,y:top+priceHeight+15,width:chartWidth,height:volumeHeight-15}:null;this.ctx.clearRect(0,0,rect.width,rect.height);if(this.data.length===0){this.drawEmptyState(rect.width/2,rect.height/2);return}
if(this.options.showGrid){this.drawGrid()}
this.ctx.save();this.ctx.beginPath();this.ctx.rect(this.priceArea.x,this.priceArea.y,this.priceArea.width,this.priceArea.height);this.ctx.clip();this.drawCandlesticks();this.ctx.restore();if(this.options.showVolume){this.ctx.save();this.ctx.beginPath();this.ctx.rect(this.volumeArea.x,this.volumeArea.y,this.volumeArea.width,this.volumeArea.height);this.ctx.clip();this.drawVolume();this.ctx.restore()}
this.drawAxes();if(this.options.showLabels){this.drawLabels()}}
drawEmptyState(centerX,centerY){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize + 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('No Trading Data Available',centerX,centerY)}
drawGrid(){this.ctx.strokeStyle=this.forge.getDesignValue('gridColor');this.ctx.lineWidth=1;this.ctx.setLineDash([2,4]);for(let i=0;i<=5;i++){const y=this.priceArea.y+(this.priceArea.height/5)*i;this.ctx.beginPath();this.ctx.moveTo(this.priceArea.x,y);this.ctx.lineTo(this.priceArea.x+this.priceArea.width,y);this.ctx.stroke()}
const visibleCandles=this.getVisibleCandles();const gridLines=Math.min(visibleCandles.length,10);for(let i=0;i<=gridLines;i++){const x=this.priceArea.x+(this.priceArea.width/gridLines)*i;this.ctx.beginPath();this.ctx.moveTo(x,this.priceArea.y);this.ctx.lineTo(x,this.priceArea.y+this.priceArea.height);this.ctx.stroke();if(this.volumeArea){this.ctx.beginPath();this.ctx.moveTo(x,this.volumeArea.y);this.ctx.lineTo(x,this.volumeArea.y+this.volumeArea.height);this.ctx.stroke()}}
this.ctx.setLineDash([])}
getVisibleCandles(){if(!this.options.showZoom){return this.data}
const startIndex=Math.floor(this.zoomStart*(this.data.length-1));const endIndex=Math.floor(this.zoomEnd*(this.data.length-1));return this.data.slice(startIndex,endIndex+1)}
drawCandlesticks(){const visibleCandles=this.getVisibleCandles();const candleSpacing=this.priceArea.width/(visibleCandles.length||1);const candleWidth=candleSpacing*this.options.candleWidth;const priceRange=this.priceRange.max-this.priceRange.min;const startIndex=this.options.showZoom?Math.floor(this.zoomStart*(this.data.length-1)):0;const visibleCount=Math.floor(this.currentProgress*visibleCandles.length);for(let i=0;i<visibleCount;i++){const candle=visibleCandles[i];const x=this.priceArea.x+(i+0.5)*candleSpacing;const isHovered=this.hoveredCandle===(i+startIndex);const highY=this.priceArea.y+((this.priceRange.max-candle.high)/priceRange)*this.priceArea.height;const lowY=this.priceArea.y+((this.priceRange.max-candle.low)/priceRange)*this.priceArea.height;const openY=this.priceArea.y+((this.priceRange.max-candle.open)/priceRange)*this.priceArea.height;const closeY=this.priceArea.y+((this.priceRange.max-candle.close)/priceRange)*this.priceArea.height;const bodyColor=candle.isBullish?this.options.colors.bullish:this.options.colors.bearish;const wickColor=candle.isBullish?this.options.colors.bullish:this.options.colors.bearish;this.ctx.strokeStyle=wickColor;this.ctx.lineWidth=this.options.wickWidth;this.ctx.beginPath();this.ctx.moveTo(x,highY);this.ctx.lineTo(x,lowY);this.ctx.stroke();if(this.options.glowEffect||isHovered){this.ctx.shadowColor=bodyColor;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur}
const bodyTop=Math.min(openY,closeY);const bodyHeight=Math.abs(closeY-openY);const adjustedWidth=isHovered?candleWidth+2:candleWidth;if(bodyHeight<1){this.ctx.strokeStyle=bodyColor;this.ctx.lineWidth=2;this.ctx.beginPath();this.ctx.moveTo(x-adjustedWidth/2,openY);this.ctx.lineTo(x+adjustedWidth/2,openY);this.ctx.stroke()}else{this.ctx.fillStyle=bodyColor;this.ctx.fillRect(x-adjustedWidth/2,bodyTop,adjustedWidth,bodyHeight);this.ctx.strokeStyle=bodyColor;this.ctx.lineWidth=1;this.ctx.strokeRect(x-adjustedWidth/2,bodyTop,adjustedWidth,bodyHeight)}
this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0;if(isHovered){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.strokeRect(x-adjustedWidth/2-1,bodyTop-1,adjustedWidth+2,bodyHeight+2)}}}
drawVolume(){if(!this.volumeArea||this.volumeRange.max===0)return;const visibleCandles=this.getVisibleCandles();const candleSpacing=this.volumeArea.width/(visibleCandles.length||1);const volumeBarWidth=candleSpacing*0.6;const startIndex=this.options.showZoom?Math.floor(this.zoomStart*(this.data.length-1)):0;const visibleCount=Math.floor(this.currentProgress*visibleCandles.length);for(let i=0;i<visibleCount;i++){const candle=visibleCandles[i];if(!candle.volume)continue;const x=this.volumeArea.x+(i+0.5)*candleSpacing;const volumeHeight=(candle.volume/this.volumeRange.max)*this.volumeArea.height;const y=this.volumeArea.y+this.volumeArea.height-volumeHeight;const color=candle.isBullish?this.options.colors.bullish:this.options.colors.bearish;this.ctx.fillStyle=this.hexToRgba(color,0.5);this.ctx.fillRect(x-volumeBarWidth/2,y,volumeBarWidth,volumeHeight);this.ctx.strokeStyle=color;this.ctx.lineWidth=1;this.ctx.strokeRect(x-volumeBarWidth/2,y,volumeBarWidth,volumeHeight)}}
drawAxes(){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.beginPath();this.ctx.moveTo(this.priceArea.x,this.priceArea.y);this.ctx.lineTo(this.priceArea.x,this.priceArea.y+this.priceArea.height);this.ctx.moveTo(this.priceArea.x,this.priceArea.y+this.priceArea.height);this.ctx.lineTo(this.priceArea.x+this.priceArea.width,this.priceArea.y+this.priceArea.height);this.ctx.stroke();if(this.volumeArea){this.ctx.beginPath();this.ctx.moveTo(this.volumeArea.x,this.volumeArea.y);this.ctx.lineTo(this.volumeArea.x,this.volumeArea.y+this.volumeArea.height);this.ctx.moveTo(this.volumeArea.x,this.volumeArea.y+this.volumeArea.height);this.ctx.lineTo(this.volumeArea.x+this.volumeArea.width,this.volumeArea.y+this.volumeArea.height);this.ctx.stroke()}
this.drawPriceAxis();if(this.volumeArea){this.drawVolumeAxis()}}
drawPriceAxis(){const steps=5;const priceRange=this.priceRange.max-this.priceRange.min;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='right';this.ctx.textBaseline='middle';for(let i=0;i<=steps;i++){const price=this.priceRange.max-(priceRange/steps)*i;const y=this.priceArea.y+(this.priceArea.height/steps)*i;this.ctx.fillText(this.forge.formatNumber(price,this.options.useKFormat,this.options.closePrefix,this.options.closeAfterfix),this.priceArea.x-10,y)}}
drawVolumeAxis(){const steps=3;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='right';this.ctx.textBaseline='middle';for(let i=0;i<=steps;i++){const volume=this.volumeRange.max-(this.volumeRange.max/steps)*i;const y=this.volumeArea.y+(this.volumeArea.height/steps)*i;this.ctx.fillText(this.forge.formatNumber(volume,this.options.useKFormat,this.options.volumePrefix,this.options.volumeAfterfix),this.volumeArea.x-10,y)}}
drawLabels(){if(this.data.length===0)return;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='top';const visibleCandles=this.getVisibleCandles();const candleSpacing=this.priceArea.width/(visibleCandles.length||1);let padding;if(window.innerWidth<=768){padding=70}else{padding=100}
let lastLabelX=this.priceArea.x;visibleCandles.forEach((candle,index)=>{const x=this.priceArea.x+(index+0.5)*candleSpacing;const label=this.formatDate(candle.date);const labelWidth=this.ctx.measureText(label).width;const nextLabelX=x+(labelWidth/2);const labelY=this.volumeArea?this.volumeArea.y+this.volumeArea.height+15:this.priceArea.y+this.priceArea.height+15;if(nextLabelX-(labelWidth/2)>lastLabelX+padding||index===0){this.ctx.fillText(label,x,labelY);lastLabelX=nextLabelX}})}
formatDate(date){if(typeof date==='string'){date=new Date(date)}
return date.toLocaleDateString('en-US',{month:'short',day:'numeric'})}
hexToRgba(hex,alpha){const r=parseInt(hex.slice(1,3),16);const g=parseInt(hex.slice(3,5),16);const b=parseInt(hex.slice(5,7),16);return `rgba(${r}, ${g}, ${b}, ${alpha})`}
handleMouseMove(e){if(!this.options.showTooltip)return;const isMobile=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent);const rect=this.canvas.getBoundingClientRect();const clientX=e.type.includes('touch')?e.touches[0].clientX:e.clientX;const clientY=e.type.includes('touch')?e.touches[0].clientY:e.clientY;const mouseX=clientX-rect.left;const mouseY=clientY-rect.top;const previousHover=this.hoveredCandle;this.hoveredCandle=-1;if(mouseX>=this.priceArea.x&&mouseX<=this.priceArea.x+this.priceArea.width&&mouseY>=this.priceArea.y&&mouseY<=this.priceArea.y+this.priceArea.height){const visibleCandles=this.getVisibleCandles();const candleSpacing=this.priceArea.width/(visibleCandles.length||1);const candleWidth=candleSpacing*this.options.candleWidth;const startIndex=this.options.showZoom?Math.floor(this.zoomStart*(this.data.length-1)):0;const candleIndex=Math.floor((mouseX-this.priceArea.x)/candleSpacing);if(candleIndex>=0&&candleIndex<visibleCandles.length){const candle=visibleCandles[candleIndex];const candleCenterX=this.priceArea.x+(candleIndex+0.5)*candleSpacing;const highY=this.priceArea.y+((this.priceRange.max-candle.high)/(this.priceRange.max-this.priceRange.min))*this.priceArea.height;const lowY=this.priceArea.y+((this.priceRange.max-candle.low)/(this.priceRange.max-this.priceRange.min))*this.priceArea.height;const openY=this.priceArea.y+((this.priceRange.max-candle.open)/(this.priceRange.max-this.priceRange.min))*this.priceArea.height;const closeY=this.priceArea.y+((this.priceRange.max-candle.close)/(this.priceRange.max-this.priceRange.min))*this.priceArea.height;const bodyTop=Math.min(openY,closeY);const bodyBottom=Math.max(openY,closeY);const distanceToVerticalLine=Math.abs(mouseX-candleCenterX);const proximityThreshold=candleWidth/2+10;if(isMobile){const isWithinBody=distanceToVerticalLine<proximityThreshold&&mouseY>=bodyTop&&mouseY<=bodyBottom;const isNearWick=distanceToVerticalLine<proximityThreshold/2&&mouseY>=highY&&mouseY<=lowY;if(isWithinBody||isNearWick){this.hoveredCandle=candleIndex+startIndex;this.showTooltip(e,this.data[this.hoveredCandle])}}else{if(this.options.showAdvancedTooltip||distanceToVerticalLine<candleSpacing*this.options.candleWidth/2){this.hoveredCandle=candleIndex+startIndex;this.showTooltip(e,this.data[this.hoveredCandle])}}}}
if(previousHover!==this.hoveredCandle){this.draw()}}
showTooltip(e,candle){if(!this.tooltip||!this.options.showTooltip)return;const change=candle.close-candle.open;const changePercent=((change/candle.open)*100);const changeClass=change>=0?'color: #10B981;':'color: #EF4444;';this.tooltip.innerHTML=`
            <div>
                <div style="font-weight: bold; margin-bottom: 4px;">${this.formatDate(candle.date)}</div>
                <div style="margin-bottom: 2px;">${this.options.openNamePrefix}Open${this.options.openNameAfterfix}: ${this.forge.formatNumber(candle.open, this.options.useKFormat, this.options.openPrefix, this.options.openAfterfix)}</div>
                <div style="margin-bottom: 2px;">${this.options.highNamePrefix}High${this.options.highNameAfterfix}: ${this.forge.formatNumber(candle.high, this.options.useKFormat, this.options.highPrefix, this.options.highAfterfix)}</div>
                <div style="margin-bottom: 2px;">${this.options.lowNamePrefix}Low${this.options.lowNameAfterfix}: ${this.forge.formatNumber(candle.low, this.options.useKFormat, this.options.lowPrefix, this.options.lowAfterfix)}</div>
                <div style="margin-bottom: 2px;">${this.options.closeNamePrefix}Close${this.options.closeNameAfterfix}: ${this.forge.formatNumber(candle.close, this.options.useKFormat, this.options.closePrefix, this.options.closeAfterfix)}</div>
                <div style="${changeClass} margin-bottom: 2px;">
                    Change: ${change >= 0 ? '+' : ''}${this.forge.formatNumber(Math.abs(change), this.options.useKFormat, this.options.closePrefix, this.options.closeAfterfix)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)
                </div>
                ${candle.volume ? `<div>${this.options.volumeNamePrefix}Volume${this.options.volumeNameAfterfix}:${this.forge.formatNumber(candle.volume,this.options.useKFormat,this.options.volumePrefix,this.options.volumeAfterfix)}</div>` : ''}
            </div>
        `;this.tooltip.style.display='block';const offsetX=this.priceArea.x+((this.hoveredCandle-(this.options.showZoom?Math.floor(this.zoomStart*(this.data.length-1)):0))+0.5)*(this.priceArea.width/this.getVisibleCandles().length)+10;const offsetY=this.priceArea.y+((this.priceRange.max-Math.max(candle.open,candle.close))/(this.priceRange.max-this.priceRange.min))*this.priceArea.height-10;this.tooltip.style.left=`${offsetX}px`;this.tooltip.style.top=`${offsetY}px`;const tooltipRect=this.tooltip.getBoundingClientRect();const canvasRect=this.canvas.getBoundingClientRect();if(offsetX+tooltipRect.width>canvasRect.width){this.tooltip.style.left=`${offsetX - tooltipRect.width - 10}px`}
if(offsetY-tooltipRect.height<this.priceArea.y){this.tooltip.style.top=`${offsetY + 20}px`}}
hideTooltip(){if(this.tooltip){this.tooltip.style.display='none'}}
redraw(animate=!1){this.updateContainerBackground();this.calculateRanges();if(animate&&this.options.animations){this.animate()}else{this.currentProgress=1;this.draw()}
if(this.options.showZoomTool&&this.zoomTool){this.updateZoomHandles()}}
destroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
window.removeEventListener('resize',this.setupCanvas);this.canvas.removeEventListener('mousedown',this.handleMouseDown);this.canvas.removeEventListener('touchstart',this.handleMouseDown);this.canvas.removeEventListener('mousemove',this.handleMouseMove);this.canvas.removeEventListener('touchmove',this.handleMouseMove);this.canvas.removeEventListener('mouseup',this.handleMouseUp);this.canvas.removeEventListener('touchend',this.handleMouseUp);this.canvas.removeEventListener('mouseleave',this.handleMouseLeave);this.canvas.removeEventListener('wheel',this.handleWheel);if(this.leftHandle){this.leftHandle.removeEventListener('mousedown',this.startDrag);this.leftHandle.removeEventListener('touchstart',this.startDrag)}
if(this.rightHandle){this.rightHandle.removeEventListener('mousedown',this.startDrag);this.rightHandle.removeEventListener('touchstart',this.startDrag)}}}
class ChartForgeBubble{constructor(containerId,options={},forge){this.container=document.getElementById(containerId);if(!this.container)throw new Error(`Container with ID '${containerId}' not found`);this.forge=forge;this.canvas=null;this.ctx=null;this.data=[];this.options={showGrid:!0,showLabels:!0,showTooltip:!0,bubbleOpacity:0.7,minBubbleRadius:8,maxBubbleRadius:50,padding:{top:40,right:40,bottom:60,left:60},multiSeries:!1,...options};this.tooltip=null;this.animationFrame=null;this.currentProgress=0;this.animationProgress=0;this.hoveredBubble=-1;this.ranges={x:{min:0,max:0},y:{min:0,max:0},z:{min:0,max:0}};this.bubbleCache=[];this.chartContainer=null;this.init();this.setupEventListeners()}
init(){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';this.container.innerHTML=`
            <div class="chartforge-bubble-container" style="width: 100%; height: 100%; position: relative; background: ${this.forge.getDesignValue('background')};">
                <canvas style="width: 100%; height: 100%;"></canvas>
                <div class="chartforge-tooltip" style="position: absolute; display: none; background: rgba(17, 24, 39, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);"></div>
            </div>
        `;this.chartContainer=this.container.querySelector('.chartforge-bubble-container');this.canvas=this.container.querySelector('canvas');this.ctx=this.canvas.getContext('2d');this.tooltip=this.container.querySelector('.chartforge-tooltip');this.setupCanvas()}
updateContainerBackground(){if(this.chartContainer){this.chartContainer.style.background=this.forge.getDesignValue('background')}}
setupCanvas(){const resizeCanvas=()=>{const rect=this.canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;this.canvas.width=rect.width*dpr;this.canvas.height=rect.height*dpr;this.ctx.scale(dpr,dpr);this.canvas.style.width=rect.width+'px';this.canvas.style.height=rect.height+'px';this.calculateBubbles();this.draw()};resizeCanvas();window.addEventListener('resize',resizeCanvas)}
setupEventListeners(){this.canvas.addEventListener('mousemove',(e)=>this.handleMouseMove(e));this.canvas.addEventListener('mouseleave',()=>this.hideTooltip());const observer=new MutationObserver(()=>{this.redraw()});observer.observe(document.documentElement,{attributes:!0,attributeFilter:['class']})}
setData(data){if(this.options.multiSeries){this.data=data.map((series,index)=>({...series,color:series.color||this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length],data:series.data||[]}))}else{this.data=[{name:'Series 1',color:this.forge.currentDesign.colors[0],data:data.map((item,index)=>({...item,color:item.color||this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length]}))}]}
this.calculateRanges();this.calculateBubbles();if(this.forge.currentDesign.animations){this.animate()}else{this.currentProgress=1;this.draw()}}
calculateRanges(){let allX=[],allY=[],allZ=[];this.data.forEach(series=>{series.data.forEach(point=>{allX.push(point.x);allY.push(point.y);allZ.push(point.z)})});this.ranges={x:{min:Math.min(...allX),max:Math.max(...allX)},y:{min:Math.min(...allY),max:Math.max(...allY)},z:{min:Math.min(...allZ),max:Math.max(...allZ)}};const xPadding=(this.ranges.x.max-this.ranges.x.min)*0.05;const yPadding=(this.ranges.y.max-this.ranges.y.min)*0.05;this.ranges.x.min-=xPadding;this.ranges.x.max+=xPadding;this.ranges.y.min-=yPadding;this.ranges.y.max+=yPadding}
calculateBubbles(){const rect=this.canvas.getBoundingClientRect();const{top,right,bottom,left}=this.options.padding;const chartWidth=rect.width-left-right;const chartHeight=rect.height-top-bottom;const xRange=this.ranges.x.max-this.ranges.x.min;const yRange=this.ranges.y.max-this.ranges.y.min;const zRange=this.ranges.z.max-this.ranges.z.min;const radiusRange=this.options.maxBubbleRadius-this.options.minBubbleRadius;this.bubbleCache=[];this.data.forEach((series,seriesIndex)=>{series.data.forEach((point,pointIndex)=>{const x=left+((point.x-this.ranges.x.min)/xRange)*chartWidth;const y=top+chartHeight-((point.y-this.ranges.y.min)/yRange)*chartHeight;const radius=this.options.minBubbleRadius+((point.z-this.ranges.z.min)/(zRange||1))*radiusRange;this.bubbleCache.push({x,y,radius,originalPoint:point,series,seriesIndex,pointIndex,color:this.options.multiSeries?series.color:(point.color||series.color)})})});this.bubbleCache.sort((a,b)=>b.radius-a.radius)}
animate(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
this.animationProgress=0;this.currentProgress=0;const startTime=Date.now();const duration=this.forge.currentDesign.animationDuration||1500;const animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/duration,1);if(this.animationProgress>=1){this.currentProgress=1}else{this.currentProgress=this.easeOutElastic(this.animationProgress)}
this.draw();if(this.animationProgress<1){this.animationFrame=requestAnimationFrame(animate)}};animate()}
easeOutElastic(t){const c4=(2*Math.PI)/3;return t===0?0:t===1?1:Math.pow(2,-10*t)*Math.sin((t*10-0.75)*c4)+1}
draw(){const rect=this.canvas.getBoundingClientRect();const{top,right,bottom,left}=this.options.padding;const chartWidth=rect.width-left-right;const chartHeight=rect.height-top-bottom;this.ctx.clearRect(0,0,rect.width,rect.height);if(this.data.length===0){this.drawEmptyState(rect.width/2,rect.height/2);return}
if(this.options.showGrid){this.drawGrid(left,top,chartWidth,chartHeight)}
this.drawBubbles();this.drawAxes(left,top,chartWidth,chartHeight);if(this.options.showLabels){this.drawLabels(left,top,chartWidth,chartHeight)}}
drawGrid(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('gridColor');this.ctx.lineWidth=1;this.ctx.setLineDash([2,4]);for(let i=0;i<=5;i++){const gridY=y+(height/5)*i;this.ctx.beginPath();this.ctx.moveTo(x,gridY);this.ctx.lineTo(x+width,gridY);this.ctx.stroke()}
for(let i=0;i<=5;i++){const gridX=x+(width/5)*i;this.ctx.beginPath();this.ctx.moveTo(gridX,y);this.ctx.lineTo(gridX,y+height);this.ctx.stroke()}
this.ctx.setLineDash([])}
drawBubbles(){const totalBubbles=this.bubbleCache.length;const visibleBubbles=Math.floor(this.currentProgress*totalBubbles);this.bubbleCache.forEach((bubble,index)=>{if(index>=visibleBubbles)return;const isHovered=this.hoveredBubble===index;const animatedRadius=bubble.radius*Math.min(this.currentProgress*1.5,1);const finalRadius=isHovered?animatedRadius*1.1:animatedRadius;if(this.forge.currentDesign.glowEffect||isHovered){this.ctx.shadowColor=bubble.color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;this.ctx.shadowOffsetX=0;this.ctx.shadowOffsetY=0}
const gradient=this.ctx.createRadialGradient(bubble.x-finalRadius*0.3,bubble.y-finalRadius*0.3,0,bubble.x,bubble.y,finalRadius);gradient.addColorStop(0,this.lightenColor(bubble.color,0.3));gradient.addColorStop(0.7,bubble.color);gradient.addColorStop(1,this.darkenColor(bubble.color,0.2));this.ctx.fillStyle=gradient;this.ctx.globalAlpha=this.options.bubbleOpacity;this.ctx.beginPath();this.ctx.arc(bubble.x,bubble.y,finalRadius,0,2*Math.PI);this.ctx.fill();this.ctx.globalAlpha=1;this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0;this.ctx.strokeStyle=this.darkenColor(bubble.color,0.3);this.ctx.lineWidth=isHovered?2:1;this.ctx.stroke();if(this.forge.currentDesign!==this.forge.designs.minimalistic){this.ctx.fillStyle=this.lightenColor(bubble.color,0.6);this.ctx.globalAlpha=0.4;this.ctx.beginPath();this.ctx.arc(bubble.x-finalRadius*0.3,bubble.y-finalRadius*0.3,finalRadius*0.2,0,2*Math.PI);this.ctx.fill();this.ctx.globalAlpha=1}
if(bubble.originalPoint.name&&finalRadius>15){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontWeight} ${Math.min(this.forge.currentDesign.fontSize, finalRadius / 3)}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText(bubble.originalPoint.name,bubble.x,bubble.y)}})}
lightenColor(color,amount){const usePound=color[0]==='#';const col=usePound?color.slice(1):color;const num=parseInt(col,16);let r=(num>>16)+amount*255;let g=(num>>8&0x00FF)+amount*255;let b=(num&0x0000FF)+amount*255;r=Math.max(0,Math.min(255,r));g=Math.max(0,Math.min(255,g));b=Math.max(0,Math.min(255,b));return(usePound?'#':'')+(r<<16|g<<8|b).toString(16).padStart(6,'0')}
darkenColor(color,amount){return this.lightenColor(color,-amount)}
drawAxes(x,y,width,height){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=2;this.ctx.beginPath();this.ctx.moveTo(x,y);this.ctx.lineTo(x,y+height);this.ctx.moveTo(x,y+height);this.ctx.lineTo(x+width,y+height);this.ctx.stroke();this.drawXAxis(x,y,width,height);this.drawYAxis(x,y,width,height)}
drawXAxis(x,y,width,height){const steps=5;const xRange=this.ranges.x.max-this.ranges.x.min;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='top';for(let i=0;i<=steps;i++){const value=this.ranges.x.min+(xRange/steps)*i;const axisX=x+(width/steps)*i;this.ctx.fillText(this.forge.formatNumber(value),axisX,y+height+10)}}
drawYAxis(x,y,width,height){const steps=5;const yRange=this.ranges.y.max-this.ranges.y.min;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='right';this.ctx.textBaseline='middle';for(let i=0;i<=steps;i++){const value=this.ranges.y.min+(yRange/steps)*(steps-i);const axisY=y+(height/steps)*i;this.ctx.fillText(this.forge.formatNumber(value),x-10,axisY)}}
drawLabels(x,y,width,height){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontWeight} ${this.forge.currentDesign.fontSize}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='top';this.ctx.fillText('X Axis',x+width/2,y+height+40);this.ctx.save();this.ctx.translate(x-40,y+height/2);this.ctx.rotate(-Math.PI/2);this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('Y Axis',0,0);this.ctx.restore();if(this.ranges.z.max>this.ranges.z.min){this.drawSizeLegend(x,y,width)}}
drawSizeLegend(x,y,width){const legendX=x+width-100;const legendY=y+20;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize - 1}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='left';this.ctx.textBaseline='top';this.ctx.fillText('Bubble Size',legendX,legendY);const sampleSizes=[{radius:this.options.minBubbleRadius,value:this.ranges.z.min},{radius:(this.options.minBubbleRadius+this.options.maxBubbleRadius)/2,value:(this.ranges.z.min+this.ranges.z.max)/2},{radius:this.options.maxBubbleRadius,value:this.ranges.z.max}];sampleSizes.forEach((sample,index)=>{const bubbleY=legendY+25+index*20;this.ctx.fillStyle=this.forge.currentDesign.colors[0];this.ctx.globalAlpha=this.options.bubbleOpacity;this.ctx.beginPath();this.ctx.arc(legendX+sample.radius,bubbleY,sample.radius,0,2*Math.PI);this.ctx.fill();this.ctx.globalAlpha=1;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.textAlign='left';this.ctx.textBaseline='middle';this.ctx.fillText(this.forge.formatNumber(sample.value),legendX+this.options.maxBubbleRadius+10,bubbleY)})}
drawEmptyState(centerX,centerY){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize + 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('No Bubble Data Available',centerX,centerY)}
handleMouseMove(e){if(!this.options.showTooltip)return;const rect=this.canvas.getBoundingClientRect();const mouseX=e.clientX-rect.left;const mouseY=e.clientY-rect.top;const previousHover=this.hoveredBubble;this.hoveredBubble=-1;for(let i=this.bubbleCache.length-1;i>=0;i--){const bubble=this.bubbleCache[i];const distance=Math.sqrt(Math.pow(mouseX-bubble.x,2)+Math.pow(mouseY-bubble.y,2));if(distance<=bubble.radius){this.hoveredBubble=i;this.showTooltip(e,bubble);break}}
if(this.hoveredBubble===-1){this.hideTooltip()}
if(previousHover!==this.hoveredBubble){this.draw()}}
showTooltip(e,bubble){if(!this.tooltip)return;const point=bubble.originalPoint;this.tooltip.innerHTML=`
            <div>
                ${point.name ? `<div style="font-weight: bold;">${point.name}</div>` : ''}
                ${this.options.multiSeries ? `<div style="color: ${bubble.color};">${bubble.series.name}</div>` : ''}
                <div>X: ${this.forge.formatNumber(point.x)}</div>
                <div>Y: ${this.forge.formatNumber(point.y)}</div>
                <div>Size: ${this.forge.formatNumber(point.z)}</div>
            </div>
        `;this.tooltip.style.display='block';this.tooltip.style.left=e.offsetX+10+'px';this.tooltip.style.top=e.offsetY-10+'px'}
hideTooltip(){if(this.tooltip){this.tooltip.style.display='none'}}
redraw(){this.updateContainerBackground();this.calculateRanges();this.calculateBubbles();this.draw()}
destroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
window.removeEventListener('resize',this.setupCanvas);this.canvas.removeEventListener('mousemove',this.handleMouseMove);this.canvas.removeEventListener('mouseleave',this.hideTooltip)}}
class ChartForgeTreeMap{constructor(containerId,options={},forge){this.container=document.getElementById(containerId);if(!this.container)throw new Error(`Container with ID '${containerId}' not found`);this.forge=forge;this.canvas=null;this.ctx=null;this.data=[];this.options={showTooltip:!0,showLabels:!0,showValues:!0,padding:{top:20,right:20,bottom:20,left:20},rectPadding:2,colorMode:'custom',customColor:!1,useKFormat:!1,valuePrefix:'',valueAfterfix:'',...options};this.tooltip=null;this.animationFrame=null;this.currentProgress=0;this.animationProgress=0;this.hoveredRect=-1;this.rectangles=[];this.totalValue=0;this.chartContainer=null;this.init();this.setupEventListeners()}
init(){this.container.innerHTML=`
            <div class="chartforge-treemap-container" style="width: 100%; height: 100%; position: relative; background: ${this.forge.getDesignValue('background')};">
                <canvas style="width: 100%; height: 100%;"></canvas>
                <div class="chartforge-tooltip" style="position: absolute; display: none; background: rgba(17, 24, 39, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);"></div>
            </div>
        `;this.chartContainer=this.container.querySelector('.chartforge-treemap-container');this.canvas=this.container.querySelector('canvas');this.ctx=this.canvas.getContext('2d');this.tooltip=this.container.querySelector('.chartforge-tooltip');this.setupCanvas()}
updateContainerBackground(){if(this.chartContainer){this.chartContainer.style.background=this.forge.getDesignValue('background')}}
setupCanvas(){const resizeCanvas=()=>{const rect=this.canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;this.canvas.width=rect.width*dpr;this.canvas.height=rect.height*dpr;this.ctx.scale(dpr,dpr);this.canvas.style.width=rect.width+'px';this.canvas.style.height=rect.height+'px';this.calculateLayout();this.redraw(!1)};resizeCanvas();window.addEventListener('resize',resizeCanvas)}
setupEventListeners(){this.canvas.addEventListener('mousemove',(e)=>this.handleMouseMove(e));this.canvas.addEventListener('mouseleave',()=>this.hideTooltip());const observer=new MutationObserver(()=>{this.redraw(!1)});observer.observe(document.documentElement,{attributes:!0,attributeFilter:['class']})}
setData(data,animate=!1){this.data=this.flattenData(data).map(item=>({...item,valuePrefix:item.valuePrefix||this.options.valuePrefix,valueAfterfix:item.valueAfterfix||this.options.valueAfterfix}));this.totalValue=this.data.reduce((sum,item)=>sum+(item.value||0),0);this.assignColors();this.calculateLayout();if(animate&&this.forge.currentDesign.animations){this.animate()}else{this.currentProgress=1;this.draw()}}
flattenData(data,parent=null){let flattened=[];data.forEach(item=>{if(item.children&&item.children.length>0){const childrenValue=item.children.reduce((sum,child)=>sum+(child.value||0),0);flattened.push({...item,value:item.value||childrenValue,parent:parent,isParent:!0});flattened=flattened.concat(this.flattenData(item.children,item.name))}else{flattened.push({...item,parent:parent,isParent:!1})}});return flattened}
assignColors(){this.data.forEach((item,index)=>{if(!item.color||!this.isValidColor(item.color)){item.color=this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length]||'#000000'}else{item.color=this.normalizeColor(item.color)}})}
isValidColor(color){const hexRegex=/^#(?:[0-9a-fA-F]{3}){1,2}$/;const rgbRegex=/^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;return hexRegex.test(color)||rgbRegex.test(color)}
normalizeColor(color){const hexRegex=/^#(?:[0-9a-fA-F]{3}){1,2}$/;if(hexRegex.test(color)){return color.length===4?'#'+color.slice(1).split('').map(c=>c+c).join(''):color}else if(/^rgb\(\s*\d{1,3}\s*,\s*\d{1,3}\s*,\s*\d{1,3}\s*\)$/.test(color)){return color}
return'#000000'}
calculateLayout(){if(this.data.length===0)return;const rect=this.canvas.getBoundingClientRect();const{top,right,bottom,left}=this.options.padding;const availableWidth=rect.width-left-right;const availableHeight=rect.height-top-bottom;const sortedData=[...this.data].sort((a,b)=>b.value-a.value);this.rectangles=this.squarify(sortedData,{x:left,y:top,width:availableWidth,height:availableHeight})}
squarify(data,bounds){if(data.length===0)return[];const rectangles=[];const totalValue=data.reduce((sum,item)=>sum+item.value,0);if(data.length===1){rectangles.push({...data[0],x:bounds.x+this.options.rectPadding,y:bounds.y+this.options.rectPadding,width:bounds.width-this.options.rectPadding*2,height:bounds.height-this.options.rectPadding*2});return rectangles}
let remaining=[...data];let currentBounds={...bounds};while(remaining.length>0){if(remaining.length===1){rectangles.push({...remaining[0],x:currentBounds.x+this.options.rectPadding,y:currentBounds.y+this.options.rectPadding,width:currentBounds.width-this.options.rectPadding*2,height:currentBounds.height-this.options.rectPadding*2});break}
const item=remaining.shift();const itemRatio=item.value/totalValue;const isWider=currentBounds.width>currentBounds.height;if(isWider){const itemWidth=currentBounds.width*itemRatio;rectangles.push({...item,x:currentBounds.x+this.options.rectPadding,y:currentBounds.y+this.options.rectPadding,width:itemWidth-this.options.rectPadding*2,height:currentBounds.height-this.options.rectPadding*2});currentBounds={x:currentBounds.x+itemWidth,y:currentBounds.y,width:currentBounds.width-itemWidth,height:currentBounds.height}}else{const itemHeight=currentBounds.height*itemRatio;rectangles.push({...item,x:currentBounds.x+this.options.rectPadding,y:currentBounds.y+this.options.rectPadding,width:currentBounds.width-this.options.rectPadding*2,height:itemHeight-this.options.rectPadding*2});currentBounds={x:currentBounds.x,y:currentBounds.y+itemHeight,width:currentBounds.width,height:currentBounds.height-itemHeight}}}
return rectangles}
animate(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
this.animationProgress=0;this.currentProgress=0;const startTime=Date.now();const duration=this.forge.currentDesign.animationDuration||1500;const animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/duration,1);if(this.animationProgress>=1){this.currentProgress=1}else{this.currentProgress=this.forge.easeInOutCubic(this.animationProgress)}
this.draw();if(this.animationProgress<1){this.animationFrame=requestAnimationFrame(animate)}};animate()}
draw(){const rect=this.canvas.getBoundingClientRect();this.ctx.clearRect(0,0,rect.width,rect.height);if(this.rectangles.length===0){this.drawEmptyState(rect.width/2,rect.height/2);return}
this.rectangles.forEach((rectangle,index)=>{this.drawRectangle(rectangle,index)})}
drawRectangle(rectangle,index){const isHovered=this.hoveredRect===index;const scale=this.currentProgress;const animatedWidth=rectangle.width*scale;const animatedHeight=rectangle.height*scale;const animatedX=rectangle.x+(rectangle.width-animatedWidth)/2;const animatedY=rectangle.y+(rectangle.height-animatedHeight)/2;const normalizedColor=this.normalizeColor(rectangle.color);if(this.forge.currentDesign.glowEffect||isHovered){this.ctx.shadowColor=normalizedColor;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;this.ctx.shadowOffsetX=0;this.ctx.shadowOffsetY=0}
const gradient=this.ctx.createLinearGradient(animatedX,animatedY,animatedX+animatedWidth,animatedY+animatedHeight);gradient.addColorStop(0,this.lightenColor(normalizedColor,0.2));gradient.addColorStop(1,this.darkenColor(normalizedColor,0.1));this.ctx.fillStyle=gradient;this.drawRoundedRect(animatedX,animatedY,animatedWidth,animatedHeight,this.forge.currentDesign.borderRadius);this.ctx.fill();this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0;this.ctx.strokeStyle=this.darkenColor(normalizedColor,0.3);this.ctx.lineWidth=isHovered?2:1;this.ctx.stroke();if(isHovered){this.ctx.strokeStyle=this.forge.getDesignValue('textColor');this.ctx.lineWidth=3;this.ctx.stroke()}
if(this.options.showLabels||this.options.showValues){this.drawRectangleLabel(rectangle,animatedX,animatedY,animatedWidth,animatedHeight)}}
drawRectangleLabel(rectangle,x,y,width,height){const centerX=x+width/2;const centerY=y+height/2;const maxFontSize=Math.min(width/8,height/4,this.forge.currentDesign.fontSize+2);const fontSize=Math.max(10,maxFontSize);this.ctx.fillStyle=this.getContrastColor(this.normalizeColor(rectangle.color));this.ctx.textAlign='center';this.ctx.textBaseline='middle';const maxWidth=width-10;const label=rectangle.name||`Item ${this.rectangles.indexOf(rectangle) + 1}`;const formattedValue=this.forge.formatNumber(rectangle.value,this.options.useKFormat,rectangle.valuePrefix,rectangle.valueAfterfix);const percentage=((rectangle.value/this.totalValue)*100).toFixed(1);if(this.options.showLabels&&this.options.showValues){this.ctx.font=`${this.forge.currentDesign.fontWeight} ${fontSize}px ${this.forge.currentDesign.fontFamily}`;const truncatedName=this.truncateText(label,maxWidth,fontSize);this.ctx.fillText(truncatedName,centerX,centerY-fontSize/2);if(height>fontSize*3){this.ctx.font=`normal ${fontSize * 0.8}px ${this.forge.currentDesign.fontFamily}`;this.ctx.fillText(`${formattedValue} (${percentage}%)`,centerX,centerY+fontSize/2)}}else if(this.options.showLabels){this.ctx.font=`${this.forge.currentDesign.fontWeight} ${fontSize}px ${this.forge.currentDesign.fontFamily}`;const truncatedName=this.truncateText(label,maxWidth,fontSize);this.ctx.fillText(truncatedName,centerX,centerY)}else if(this.options.showValues&&height>fontSize*3){this.ctx.font=`normal ${fontSize * 0.8}px ${this.forge.currentDesign.fontFamily}`;this.ctx.fillText(`${formattedValue} (${percentage}%)`,centerX,centerY)}}
truncateText(text,maxWidth,fontSize){this.ctx.font=`${this.forge.currentDesign.fontWeight} ${fontSize}px ${this.forge.currentDesign.fontFamily}`;if(this.ctx.measureText(text).width<=maxWidth){return text}
let truncated=text;while(this.ctx.measureText(truncated+'...').width>maxWidth&&truncated.length>0){truncated=truncated.slice(0,-1)}
return truncated+'...'}
getContrastColor(backgroundColor){const color=this.normalizeColor(backgroundColor);const r=parseInt(color.slice(1,3),16);const g=parseInt(color.slice(3,5),16);const b=parseInt(color.slice(5,7),16);const luminance=(0.299*r+0.587*g+0.114*b)/255;return luminance>0.5?'#000000':'#FFFFFF'}
lightenColor(color,amount){try{if(color.startsWith('rgb')){const match=color.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);if(match){let r=parseInt(match[1])+amount*255;let g=parseInt(match[2])+amount*255;let b=parseInt(match[3])+amount*255;r=Math.max(0,Math.min(255,r));g=Math.max(0,Math.min(255,g));b=Math.max(0,Math.min(255,b));return `rgb(${r}, ${g}, ${b})`}}else{const usePound=color[0]==='#';const col=usePound?color.slice(1):color;const num=parseInt(col,16);let r=(num>>16)+amount*255;let g=(num>>8&0x00FF)+amount*255;let b=(num&0x0000FF)+amount*255;r=Math.max(0,Math.min(255,r));g=Math.max(0,Math.min(255,g));b=Math.max(0,Math.min(255,b));return(usePound?'#':'')+(r<<16|g<<8|b).toString(16).padStart(6,'0')}}catch(e){return'#000000'}}
darkenColor(color,amount){return this.lightenColor(color,-amount)}
drawRoundedRect(x,y,width,height,radius){this.ctx.beginPath();this.ctx.moveTo(x+radius,y);this.ctx.lineTo(x+width-radius,y);this.ctx.quadraticCurveTo(x+width,y,x+width,y+radius);this.ctx.lineTo(x+width,y+height-radius);this.ctx.quadraticCurveTo(x+width,y+height,x+width-radius,y+height);this.ctx.lineTo(x+radius,y+height);this.ctx.quadraticCurveTo(x,y+height,x,y+height-radius);this.ctx.lineTo(x,y+radius);this.ctx.quadraticCurveTo(x,y,x+radius,y);this.ctx.closePath()}
drawEmptyState(centerX,centerY){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize + 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('No TreeMap Data Available',centerX,centerY)}
handleMouseMove(e){if(!this.options.showTooltip)return;const rect=this.canvas.getBoundingClientRect();const mouseX=e.clientX-rect.left;const mouseY=e.clientY-rect.top;const previousHover=this.hoveredRect;this.hoveredRect=-1;this.rectangles.forEach((rectangle,index)=>{if(mouseX>=rectangle.x&&mouseX<=rectangle.x+rectangle.width&&mouseY>=rectangle.y&&mouseY<=rectangle.y+rectangle.height){this.hoveredRect=index;this.showTooltip(e,rectangle)}});if(this.hoveredRect===-1){this.hideTooltip()}
if(previousHover!==this.hoveredRect){this.draw()}}
showTooltip(e,rectangle){if(!this.tooltip)return;const percentage=((rectangle.value/this.totalValue)*100).toFixed(1);const label=rectangle.name||`Item ${this.rectangles.indexOf(rectangle) + 1}`;const formattedValue=this.forge.formatNumber(rectangle.value,this.options.useKFormat,rectangle.valuePrefix,rectangle.valueAfterfix);this.tooltip.innerHTML=`
            <div>
                <div style="font-weight: bold;">${label}</div>
                ${rectangle.category ? `<div style="color: ${this.normalizeColor(rectangle.color)};">Category:${rectangle.category}</div>` : ''}
                ${rectangle.parent ? `<div>Parent:${rectangle.parent}</div>` : ''}
                <div>Value: ${formattedValue}</div>
                <div>Percentage: ${percentage}%</div>
            </div>
        `;this.tooltip.style.display='block';const offsetX=e.offsetX+10;const offsetY=e.offsetY-10;this.tooltip.style.left=`${offsetX}px`;this.tooltip.style.top=`${offsetY}px`;const tooltipRect=this.tooltip.getBoundingClientRect();const canvasRect=this.canvas.getBoundingClientRect();if(offsetX+tooltipRect.width>canvasRect.width){this.tooltip.style.left=`${offsetX - tooltipRect.width - 10}px`}
if(offsetY-tooltipRect.height<0){this.tooltip.style.top=`${offsetY + 20}px`}}
hideTooltip(){if(this.tooltip){this.tooltip.style.display='none'}}
redraw(animate=!1){this.updateContainerBackground();this.calculateLayout();if(animate&&this.forge.currentDesign.animations){this.animate()}else{this.currentProgress=1;this.draw()}}
destroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
window.removeEventListener('resize',this.setupCanvas);this.canvas.removeEventListener('mousemove',this.handleMouseMove);this.canvas.removeEventListener('mouseleave',this.hideTooltip)}}
class ChartForgeRadialBar{constructor(containerId,options={},forge){this.container=document.getElementById(containerId);if(!this.container)throw new Error(`Container with ID '${containerId}' not found`);this.forge=forge;this.canvas=null;this.ctx=null;this.data=[];this.options={showTooltip:!0,showValues:!0,showLegend:!1,startAngle:-Math.PI/2,endAngle:Math.PI*1.5,innerRadius:0.3,barWidth:20,barSpacing:10,padding:{top:40,right:40,bottom:40,left:40},centerText:!0,customColor:!1,fillOpacity:0.3,useKFormat:!1,valuePrefix:'',valueAfterfix:'',...options};this.tooltip=null;this.animationFrame=null;this.currentProgress=0;this.animationProgress=0;this.hoveredBar=-1;this.centerX=0;this.centerY=0;this.maxRadius=0;this.chartContainer=null;this.legendContainer=null;this.init();this.setupEventListeners()}
init(){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';this.container.innerHTML=`
            <div class="chartforge-radialbar-container" style="width: 100%; height: 100%; position: relative; background: ${this.forge.getDesignValue('background')};">
                <canvas style="width: 100%; height: 100%;"></canvas>
                <div class="chartforge-tooltip" style="position: absolute; display: none; background: rgba(17, 24, 39, 0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);"></div>
                <div class="chartforge-legend" style="position: absolute; top: 20px; right: 20px; background: ${legendBackground}; padding: 16px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); max-width: 200px; z-index: 1000; display: ${this.options.showLegend ? 'block' : 'none'};">
                    <div class="legend-items"></div>
                </div>
            </div>
        `;this.chartContainer=this.container.querySelector('.chartforge-radialbar-container');this.canvas=this.container.querySelector('canvas');this.ctx=this.canvas.getContext('2d');this.tooltip=this.container.querySelector('.chartforge-tooltip');this.legendContainer=this.container.querySelector('.legend-items');this.setupCanvas()}
updateContainerBackground(){if(this.chartContainer){this.chartContainer.style.background=this.forge.getDesignValue('background')}
const legendElement=this.container.querySelector('.chartforge-legend');if(legendElement){const legendBackground=this.forge.isDarkMode()?'rgba(31, 41, 55, 0.9)':'rgba(255, 255, 255, 0.9)';legendElement.style.background=legendBackground}}
setupCanvas(){const resizeCanvas=()=>{const rect=this.canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;this.canvas.width=rect.width*dpr;this.canvas.height=rect.height*dpr;this.ctx.scale(dpr,dpr);this.canvas.style.width=rect.width+'px';this.canvas.style.height=rect.height+'px';this.calculateDimensions();this.redraw(!1)};resizeCanvas();window.addEventListener('resize',resizeCanvas)}
setupEventListeners(){this.canvas.addEventListener('mousemove',(e)=>this.handleMouseMove(e));this.canvas.addEventListener('mouseleave',()=>this.hideTooltip());const observer=new MutationObserver(()=>{this.redraw(!1)});observer.observe(document.documentElement,{attributes:!0,attributeFilter:['class']})}
setData(data,animate=!1){this.data=data.map((item,index)=>({...item,color:item.color||this.forge.currentDesign.colors[index%this.forge.currentDesign.colors.length],max:item.max||Math.max(...data.map(d=>d.value)),valuePrefix:item.valuePrefix||this.options.valuePrefix,valueAfterfix:item.valueAfterfix||this.options.valueAfterfix}));this.calculateDimensions();if(animate&&this.forge.currentDesign.animations){this.animate()}else{this.currentProgress=1;this.draw()}
this.updateLegend()}
calculateDimensions(){const rect=this.canvas.getBoundingClientRect();const{top,right,bottom,left}=this.options.padding;this.centerX=rect.width/2;this.centerY=rect.height/2;const availableWidth=rect.width-left-right;const availableHeight=rect.height-top-bottom;const maxDimension=Math.min(availableWidth,availableHeight);const totalBarSpace=this.data.length*(this.options.barWidth+this.options.barSpacing);this.maxRadius=(maxDimension/2)-totalBarSpace/2;this.maxRadius=Math.max(this.maxRadius,50)}
animate(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
this.animationProgress=0;this.currentProgress=0;const startTime=Date.now();const duration=this.forge.currentDesign.animationDuration||2000;const animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/duration,1);if(this.animationProgress>=1){this.currentProgress=1}else{this.currentProgress=this.forge.easeInOutCubic(this.animationProgress)}
this.draw();if(this.animationProgress<1){this.animationFrame=requestAnimationFrame(animate)}};animate()}
draw(){const rect=this.canvas.getBoundingClientRect();this.ctx.clearRect(0,0,rect.width,rect.height);if(this.data.length===0){this.drawEmptyState(rect.width/2,rect.height/2);return}
this.drawBackgroundCircles();this.data.forEach((item,index)=>{this.drawRadialBar(item,index)});if(this.options.centerText){this.drawCenterText()}
if(this.options.showValues){this.data.forEach((item,index)=>{const radius=this.getBarRadius(index);const percentage=Math.min(item.value/item.max,1);const animatedPercentage=percentage*this.currentProgress;const totalAngle=this.options.endAngle-this.options.startAngle;const endAngle=this.options.startAngle+(totalAngle*animatedPercentage);if(animatedPercentage>0.1){this.drawValueIndicator(item,radius,endAngle,percentage)}})}}
drawBackgroundCircles(){this.ctx.strokeStyle=this.forge.getDesignValue('gridColor');this.ctx.lineWidth=1;this.ctx.setLineDash([2,4]);this.data.forEach((item,index)=>{const radius=this.getBarRadius(index);this.ctx.beginPath();this.ctx.arc(this.centerX,this.centerY,radius,0,2*Math.PI);this.ctx.stroke()});this.ctx.setLineDash([])}
drawRadialBar(item,index){const radius=this.getBarRadius(index);const percentage=Math.min(item.value/item.max,1);const animatedPercentage=percentage*this.currentProgress;const totalAngle=this.options.endAngle-this.options.startAngle;const endAngle=this.options.startAngle+(totalAngle*animatedPercentage);const isHovered=this.hoveredBar===index;const barWidth=isHovered?this.options.barWidth+2:this.options.barWidth;if(this.forge.currentDesign.glowEffect||isHovered){this.ctx.shadowColor=item.color;this.ctx.shadowBlur=this.forge.currentDesign.shadowBlur;this.ctx.shadowOffsetX=0;this.ctx.shadowOffsetY=0}
const gradient=this.ctx.createRadialGradient(this.centerX,this.centerY,radius-barWidth/2,this.centerX,this.centerY,radius+barWidth/2);gradient.addColorStop(0,this.lightenColor(item.color,0.2));gradient.addColorStop(0.5,item.color);gradient.addColorStop(1,this.darkenColor(item.color,0.2));this.ctx.strokeStyle=gradient;this.ctx.lineWidth=barWidth;this.ctx.lineCap='round';this.ctx.beginPath();this.ctx.arc(this.centerX,this.centerY,radius,this.options.startAngle,endAngle);this.ctx.stroke();this.ctx.shadowColor='transparent';this.ctx.shadowBlur=0;if(animatedPercentage>0.05){this.drawEndCap(radius,endAngle,item.color,barWidth)}}
drawEndCap(radius,angle,color,width){const capX=this.centerX+Math.cos(angle)*radius;const capY=this.centerY+Math.sin(angle)*radius;this.ctx.fillStyle=color;this.ctx.beginPath();this.ctx.arc(capX,capY,width/3,0,2*Math.PI);this.ctx.fill();this.ctx.fillStyle=this.lightenColor(color,0.4);this.ctx.beginPath();this.ctx.arc(capX-width/6,capY-width/6,width/6,0,2*Math.PI);this.ctx.fill()}
drawValueIndicator(item,radius,angle,percentage){const indicatorX=this.centerX+Math.cos(angle)*(radius+this.options.barWidth+4);const indicatorY=this.centerY+Math.sin(angle)*(radius+this.options.barWidth+4);const formattedValue=this.forge.formatNumber(item.value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);this.ctx.font=`${this.forge.currentDesign.fontWeight} ${this.forge.currentDesign.fontSize - 2}px ${this.forge.currentDesign.fontFamily}`;const textMetrics=this.ctx.measureText(formattedValue);const textWidth=textMetrics.width+8;const textHeight=this.forge.currentDesign.fontSize+4;this.ctx.fillStyle=this.hexToRgba(item.color,this.options.fillOpacity);this.ctx.beginPath();this.ctx.roundRect(indicatorX-textWidth/2,indicatorY-textHeight/2,textWidth,textHeight,4);this.ctx.fill();this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText(formattedValue,indicatorX,indicatorY)}
getBarRadius(index){return this.maxRadius*this.options.innerRadius+index*(this.options.barWidth+this.options.barSpacing)+this.options.barWidth/2}
drawCenterText(){const totalValue=this.data.reduce((sum,item)=>sum+item.value,0);const averagePercentage=this.data.length>0?(this.data.reduce((sum,item)=>sum+(item.value/item.max),0)/this.data.length)*100:0;this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.font=`bold ${this.forge.currentDesign.fontSize + 4}px ${this.forge.currentDesign.fontFamily}`;this.ctx.fillText('Overview',this.centerX,this.centerY-20);this.ctx.font=`bold ${this.forge.currentDesign.fontSize + 8}px ${this.forge.currentDesign.fontFamily}`;this.ctx.fillText(`${averagePercentage.toFixed(1)}%`,this.centerX,this.centerY+5);this.ctx.font=`${this.forge.currentDesign.fontSize - 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.fillStyle=this.forge.getDesignValue('gridColor');this.ctx.fillText('Average Progress',this.centerX,this.centerY+25)}
updateLegend(){if(!this.legendContainer)return;this.legendContainer.parentElement.style.display=this.options.showLegend?'block':'none';if(!this.options.showLegend)return;this.legendContainer.innerHTML=this.data.map((item,index)=>{const percentage=((item.value/item.max)*100).toFixed(1);const label=item.name||`Item ${index + 1}`;const formattedValue=this.forge.formatNumber(item.value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);const formattedMax=this.forge.formatNumber(item.max,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);return `
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: ${this.forge.currentDesign.fontSize}px; font-family: ${this.forge.currentDesign.fontFamily};">
                    <div style="display: flex; align-items: center;">
                        <div style="width: 4px; height: 20px; background-color: ${item.color}; margin-right: 8px; border-radius: 2px;"></div>
                        <span style="color: ${this.forge.getDesignValue('textColor')};">${label}</span>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-weight: bold; color: ${this.forge.getDesignValue('textColor')};">${percentage}%</div>
                        <div style="font-size: ${this.forge.currentDesign.fontSize - 2}px; color: ${this.forge.getDesignValue('textColor')}; font-style: italic;">${formattedValue}/${formattedMax}</div>
                    </div>
                </div>
            `}).join('')}
hexToRgba(hex,alpha){const r=parseInt(hex.slice(1,3),16);const g=parseInt(hex.slice(3,5),16);const b=parseInt(hex.slice(5,7),16);return `rgba(${r}, ${g}, ${b}, ${alpha})`}
lightenColor(color,amount){const usePound=color[0]==='#';const col=usePound?color.slice(1):color;const num=parseInt(col,16);let r=(num>>16)+amount*255;let g=(num>>8&0x00FF)+amount*255;let b=(num&0x0000FF)+amount*255;r=Math.max(0,Math.min(255,r));g=Math.max(0,Math.min(255,g));b=Math.max(0,Math.min(255,b));return(usePound?'#':'')+(r<<16|g<<8|b).toString(16).padStart(6,'0')}
darkenColor(color,amount){return this.lightenColor(color,-amount)}
drawEmptyState(centerX,centerY){this.ctx.fillStyle=this.forge.getDesignValue('textColor');this.ctx.font=`${this.forge.currentDesign.fontSize + 2}px ${this.forge.currentDesign.fontFamily}`;this.ctx.textAlign='center';this.ctx.textBaseline='middle';this.ctx.fillText('No Radial Bar Data Available',centerX,centerY)}
handleMouseMove(e){if(!this.options.showTooltip)return;const rect=this.canvas.getBoundingClientRect();const mouseX=e.clientX-rect.left;const mouseY=e.clientY-rect.top;const previousHover=this.hoveredBar;this.hoveredBar=-1;const dx=mouseX-this.centerX;const dy=mouseY-this.centerY;const distance=Math.sqrt(dx*dx+dy*dy);const angle=Math.atan2(dy,dx);this.data.forEach((item,index)=>{const barRadius=this.getBarRadius(index);const barInnerRadius=barRadius-this.options.barWidth/2;const barOuterRadius=barRadius+this.options.barWidth/2;if(distance>=barInnerRadius&&distance<=barOuterRadius){const percentage=item.value/item.max;const totalAngle=this.options.endAngle-this.options.startAngle;const barEndAngle=this.options.startAngle+(totalAngle*percentage);let normalizedAngle=angle;if(normalizedAngle<this.options.startAngle){normalizedAngle+=2*Math.PI}
if(normalizedAngle>=this.options.startAngle&&normalizedAngle<=barEndAngle){this.hoveredBar=index;this.showTooltip(e,item,index)}}});if(this.hoveredBar===-1){this.hideTooltip()}
if(previousHover!==this.hoveredBar){this.draw()}}
showTooltip(e,item,index){if(!this.tooltip)return;const percentage=((item.value/item.max)*100).toFixed(1);const label=item.name||`Item ${index + 1}`;const formattedValue=this.forge.formatNumber(item.value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);const formattedMax=this.forge.formatNumber(item.max,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);const formattedRemaining=this.forge.formatNumber(item.max-item.value,this.options.useKFormat,item.valuePrefix,item.valueAfterfix);this.tooltip.innerHTML=`
            <div>
                <div style="font-weight: bold; color: ${item.color};">${label}</div>
                <div>Progress: ${percentage}%</div>
                <div>Value: ${formattedValue}</div>
                <div>Target: ${formattedMax}</div>
                <div>Remaining: ${formattedRemaining}</div>
            </div>
        `;this.tooltip.style.display='block';this.tooltip.style.left=e.offsetX+10+'px';this.tooltip.style.top=e.offsetY-10+'px'}
hideTooltip(){if(this.tooltip){this.tooltip.style.display='none'}}
redraw(animate=!1){this.updateContainerBackground();this.calculateDimensions();if(animate&&this.forge.currentDesign.animations){this.animate()}else{this.currentProgress=1;this.draw()}
this.updateLegend()}
destroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame)}
window.removeEventListener('resize',this.setupCanvas);this.canvas.removeEventListener('mousemove',this.handleMouseMove);this.canvas.removeEventListener('mouseleave',this.hideTooltip)}}